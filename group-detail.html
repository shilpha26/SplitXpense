<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Group Details - SplitEasy</title>
    <!-- Google Fonts - Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#22c55e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="description" content="SplitEasy - View and manage your group expenses">
</head>
<body>
    <!-- Header -->
    <header class="group-header">
        <div class="container">
            <div class="group-header-left">
                <button class="btn-back" id="backBtn" onclick="goBack()">‚Üê</button>
                <div class="group-info">
                    <h1 id="groupName">Loading...</h1>
                    <p id="groupMeta">Loading group details...</p>
                </div>
            </div>
            <div class="group-actions">
                <button class="btn-secondary" id="shareBtn" onclick="shareGroup()">Share</button>
                <button class="btn-success" id="editBtn" onclick="handleEditGroup()">Edit</button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container">
        <!-- Total Expenses Card -->
        <div class="total-expenses">
            <h2 id="totalExpensesAmount">‚Çπ0.00</h2>
            <p>Total Expenses</p>
        </div>

        <!-- Expenses Section -->
        <section class="expenses-section">
            <div class="section-header">
                <button class="btn-success" onclick="showAddExpenseModal()">Add Expense</button>
                <button class="btn-success hide-on-mobile" onclick="showDetailsView()">Show details</button>
            </div>
            <div id="expensesList" class="expenses-list">
                <!-- Expenses will be loaded here -->
            </div>
            <div id="noExpenses" class="empty-state">
                <p>No expenses yet</p>
                <p>Start tracking your shared expenses by adding the first one. It's quick and easy!</p>
                <button class="btn-success btn-large" onclick="showAddExpenseModal()">Add First Expense</button>
            </div>
        </section>

        <!-- Balances Section -->
        <section class="balances-section">
            <div class="balances-header">
                <h3>Settlements needed</h3>
            </div>
            <div id="balancesList" class="balances-list">
                <!-- Settlements will be calculated and shown here -->
            </div>
            <div class="show-on-mobile-only" style="margin-top: 20px; text-align: center;">
                <button class="btn-success" onclick="showDetailsView()">Show details</button>
            </div>
        </section>

    </main>

    <!-- Details View (Tabbed Interface) -->
    <div id="detailsView" class="details-view" style="display: none;">
        <div class="container">
            <!-- Tab Navigation -->
            <div class="tab-navigation">
                <button class="tab-btn active" id="balancesTab" onclick="switchTab('balances')">Lending / Borrowing</button>
                <button class="tab-btn" id="expensesTab" onclick="switchTab('expenses')">Expense</button>
            </div>

            <!-- Balances Tab Content -->
            <div id="balancesTabContent" class="tab-content active">
                <div id="detailsIndividualBalances" class="individual-balances">
                    <!-- Individual balances will be shown here -->
                </div>
                <div class="balance-legend">
                    <span class="legend-item"><span class="legend-color blue"></span> Amount to receive</span>
                    <span class="legend-item"><span class="legend-color red"></span> Amount to pay</span>
                </div>
            </div>

            <!-- Expenses Tab Content -->
            <div id="expensesTabContent" class="tab-content">
                <div class="section-header">
                    <h3>Expenses</h3>
                </div>
                <div id="detailsExpensesList" class="expenses-list">
                    <!-- Expenses will be loaded here -->
                </div>
                <div id="detailsNoExpenses" class="empty-state">
                    <p>No expenses yet</p>
                    <p>Start tracking your shared expenses by adding the first one. It's quick and easy!</p>
                    <button class="btn-success btn-large" onclick="showAddExpenseModal()">Add First Expense</button>
                </div>
                <div class="total-expense-summary">
                    <span class="total-label">Total Group Expense</span>
                    <span class="total-amount" id="detailsTotalExpensesAmount">‚Çπ0.00</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Expense Modal -->
    <div id="addExpenseModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Add Expense</h3>
                <span class="close" onclick="closeAddExpenseModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="expenseDescription">Description</label>
                    <input type="text" id="expenseDescription" placeholder="e.g., Dinner, Gas, Groceries" maxlength="200" required>
                    <small class="form-help" id="expenseDescriptionHelp">Max 200 characters</small>
                </div>
                <div class="form-group">
                    <label for="expenseAmount">Amount (‚Çπ)</label>
                    <input type="number" id="expenseAmount" placeholder="0.00" step="0.01" min="0.01" max="10000000" required oninput="validateExpenseAmount(this)">
                    <small class="form-help" id="expenseAmountHelp">Enter amount between ‚Çπ0.01 and ‚Çπ10,000,000</small>
                </div>
                <div class="form-group">
                    <label for="expensePaidBy">Paid By</label>
                    <select id="expensePaidBy" required>
                        <option value="">Select who paid</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="expenseSplitType">Split Type</label>
                    <select id="expenseSplitType" onchange="handleSplitTypeChange()">
                        <option value="equal">Equal Split</option>
                        <option value="custom">Custom Amounts</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Split Between</label>
                    <div class="selection-container">
                        <div class="selection-header">
                            <span>Select Members</span>
                            <div class="selection-actions">
                                <button class="selection-action" onclick="selectAllExpenseMembers()">Select All</button>
                                <button class="selection-action" onclick="clearAllExpenseMembers()">Clear All</button>
                            </div>
                        </div>
                        <div class="selectable-grid" id="expenseSplitGrid">
                            <!-- Member checkboxes will be added here -->
                        </div>
                    </div>
                    <!-- Custom Amounts Inputs (hidden by default) -->
                    <div id="customAmountsContainer" style="display: none; margin-top: 1rem;">
                        <div class="custom-amounts-header">
                            <span>Enter amount for each person:</span>
                            <span id="customAmountsTotal" class="custom-amounts-total">Total: ‚Çπ0.00</span>
                        </div>
                        <div id="customAmountsList" class="custom-amounts-list">
                            <!-- Custom amount inputs will be added here -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" onclick="closeAddExpenseModal()">Cancel</button>
                <button type="button" class="btn-success" onclick="addExpense()">Add Expense</button>
            </div>
        </div>
    </div>

    <!-- Edit Expense Modal -->
    <div id="editExpenseModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Expense</h3>
                <span class="close" onclick="closeEditExpenseModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="editExpenseDescription">Description</label>
                    <input type="text" id="editExpenseDescription" placeholder="e.g., Dinner, Gas, Groceries" maxlength="200" required>
                    <small class="form-help" id="editExpenseDescriptionHelp">Max 200 characters</small>
                </div>
                <div class="form-group">
                    <label for="editExpenseAmount">Amount (‚Çπ)</label>
                    <input type="number" id="editExpenseAmount" placeholder="0.00" step="0.01" min="0.01" max="10000000" required oninput="validateExpenseAmount(this)">
                    <small class="form-help" id="editExpenseAmountHelp">Enter amount between ‚Çπ0.01 and ‚Çπ10,000,000</small>
                </div>
                <div class="form-group">
                    <label for="editExpensePaidBy">Paid By</label>
                    <select id="editExpensePaidBy" required>
                        <option value="">Select who paid</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="editExpenseSplitType">Split Type</label>
                    <select id="editExpenseSplitType" onchange="handleEditSplitTypeChange()">
                        <option value="equal">Equal Split</option>
                        <option value="custom">Custom Amounts</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Split Between</label>
                    <div class="selection-container">
                        <div class="selection-header">
                            <span>Select Members</span>
                            <div class="selection-actions">
                                <button class="selection-action" onclick="selectAllEditExpenseMembers()">Select All</button>
                                <button class="selection-action" onclick="clearAllEditExpenseMembers()">Clear All</button>
                            </div>
                        </div>
                        <div class="selectable-grid" id="editExpenseSplitGrid">
                            <!-- Member checkboxes will be added here -->
                        </div>
                    </div>
                    <!-- Custom Amounts Inputs (hidden by default) -->
                    <div id="editCustomAmountsContainer" style="display: none; margin-top: 1rem;">
                        <div class="custom-amounts-header">
                            <span>Enter amount for each person:</span>
                            <span id="editCustomAmountsTotal" class="custom-amounts-total">Total: ‚Çπ0.00</span>
                        </div>
                        <div id="editCustomAmountsList" class="custom-amounts-list">
                            <!-- Custom amount inputs will be added here -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" onclick="closeEditExpenseModal()">Cancel</button>
                <button type="button" class="btn-success" onclick="saveExpenseChanges()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Share Group Modal -->
    <div id="shareModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Share Group</h3>
                <span class="close" onclick="closeShareModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="shareLink">Share Link</label>
                    <div style="display: grid; grid-template-columns: 1fr auto; gap: 10px; width: 100%;">
                        <input type="text" id="shareLink" style="width: 100%; padding: 12px; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 14px; box-sizing: border-box;" readonly>
                        <button type="button" class="btn-success" style="padding: 12px 20px; white-space: nowrap;" onclick="copyShareLink()">Copy</button>
                    </div>
                </div>
                
                <!-- Snapshot Preview -->
                <div class="form-group" id="snapshotPreviewSection">
                    <label>Settlements Snapshot</label>
                    <div id="snapshotPreview" class="snapshot-preview">
                        <p class="snapshot-loading">Generating preview...</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" onclick="closeShareModal()">Close</button>
                <button type="button" class="btn-success" onclick="shareWithSnapshot()" id="shareWithSnapshotBtn">
                    Share with Snapshot
                </button>
            </div>
        </div>
    </div>

    <!-- Edit Group Modal -->
    <div id="editGroupModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Group</h3>
                <span class="close" onclick="closeEditGroupModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="editGroupName">Group Name</label>
                    <input type="text" id="editGroupName" required>
                </div>
                <div class="form-group">
                    <label>Members</label>
                    <div class="selection-container">
                        <div class="selection-header">
                            <span>Edit Members</span>
                            <div class="selection-actions">
                                <button class="selection-action" onclick="selectAllGroupMembers()">Select All</button>
                                <button class="selection-action" onclick="clearAllGroupMembers()">Clear All</button>
                            </div>
                        </div>
                        <div class="selectable-grid" id="editGroupMembersGrid">
                            <!-- Members will be loaded here -->
                        </div>
                        <div class="add-item-section">
                            <input type="text" class="add-item-input" id="editGroupNewMemberInput" placeholder="Add new member">
                            <button class="btn-add" onclick="addNewGroupMember()" title="Add member">+</button>
                        </div>
                        <div class="dynamic-items" id="editGroupDynamicMembers">
                            <!-- Dynamically added members will appear here -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer-with-delete">
                <div class="modal-footer-left">
                    <button type="button" class="btn-danger" onclick="deleteGroupConfirm()">Delete Group</button>
                </div>
                <div class="modal-footer-right">
                    <button type="button" class="btn-secondary" onclick="closeEditGroupModal()">Cancel</button>
                    <button type="button" class="btn-success" onclick="saveGroupChanges()">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div id="notification" class="notification" style="display: none;"></div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="js/shared-utils.js"></script>
    <script>
        // ========================================
        // GLOBAL VARIABLES
        // ========================================
        let currentGroup = null;
        let currentGroupId = null;
        let editingExpenseId = null;
        let dynamicMemberCounter = 0;
        let autoRefreshInterval = null; // For automatic polling

        // Store group globally so it's accessible everywhere
        window.currentGroup = null;
        
        // Helper function to update currentGroup from real-time sync
        window.setCurrentGroup = function(group) {
            currentGroup = group;
            window.currentGroup = group;
        };

        // ========================================
        // DETAILS VIEW & TAB NAVIGATION
        // ========================================
        function showDetailsView() {
            const mainContent = document.querySelector('main.container');
            const detailsView = document.getElementById('detailsView');
            
            if (mainContent) mainContent.style.display = 'none';
            if (detailsView) {
                detailsView.style.display = 'block';
                // Scroll to top of the page
                window.scrollTo({ top: 0, behavior: 'smooth' });
                // Switch to balances tab by default
                switchTab('balances');
                // Update details view with current data
                updateDetailsView();
            }
        }

        function hideDetailsView() {
            const mainContent = document.querySelector('main.container');
            const detailsView = document.getElementById('detailsView');
            
            if (detailsView) detailsView.style.display = 'none';
            if (mainContent) mainContent.style.display = 'block';
        }

        function switchTab(tabName) {
            // Update tab buttons
            document.getElementById('balancesTab').classList.toggle('active', tabName === 'balances');
            document.getElementById('expensesTab').classList.toggle('active', tabName === 'expenses');
            
            // Update tab content
            document.getElementById('balancesTabContent').classList.toggle('active', tabName === 'balances');
            document.getElementById('expensesTabContent').classList.toggle('active', tabName === 'expenses');
            
            // Update content when switching tabs
            if (tabName === 'balances') {
                updateBalancesTab();
            } else if (tabName === 'expenses') {
                updateExpensesTab();
            }
        }

        function updateDetailsView() {
            updateBalancesTab();
            updateExpensesTab();
        }

        function updateBalancesTab() {
            if (!currentGroup || !currentGroup.expenses || currentGroup.expenses.length === 0) {
                const detailsBalances = document.getElementById('detailsIndividualBalances');
                if (detailsBalances) {
                    detailsBalances.innerHTML = '<p class="no-balances">No balances to display</p>';
                }
                return;
            }

            // Get only participants (names), not member IDs
            const participants = Array.isArray(currentGroup.participants) ? currentGroup.participants : [];
            
            // Calculate balances using only participants
            const balances = {};
            participants.forEach(participant => {
                balances[participant] = 0;
            });

            currentGroup.expenses.forEach(expense => {
                const amount = parseFloat(expense.amount);
                // Filter splitBetween to only include participants (names, not IDs)
                const splitBetween = (expense.splitBetween || []).filter(name => 
                    participants.includes(name) && 
                    !name.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) &&
                    !name.match(/^user\d+$/i) &&
                    !name.match(/^[a-zA-Z]+\d+$/)
                );
                if (splitBetween.length === 0) return; // Skip if no valid participants
                const perPerson = amount / splitBetween.length;

                // Only count if paidBy is a participant (name, not ID)
                if (participants.includes(expense.paidBy) && 
                    !expense.paidBy.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) &&
                    !expense.paidBy.match(/^user\d+$/i) &&
                    !expense.paidBy.match(/^[a-zA-Z]+\d+$/)) {
                    if (balances[expense.paidBy] !== undefined) {
                        balances[expense.paidBy] += amount;
                    }
                }

                splitBetween.forEach(participant => {
                    if (balances[participant] !== undefined) {
                        balances[participant] -= perPerson;
                    }
                });
            });

            // Display in details view
            const detailsBalances = document.getElementById('detailsIndividualBalances');
            if (detailsBalances) {
                const balanceEntries = Object.entries(balances)
                    .map(([member, amount]) => ({ name: member, amount }))
                    .sort((a, b) => {
                        if (a.amount < 0 && b.amount < 0) return a.amount - b.amount;
                        if (a.amount > 0 && b.amount > 0) return b.amount - a.amount;
                        return a.amount < b.amount ? -1 : 1;
                    });

                if (balanceEntries.length > 0) {
                    detailsBalances.innerHTML = `
                        <div class="individual-balances-list">
                            ${balanceEntries.map(({ name, amount }) => `
                                <div class="balance-item-simple">
                                    <span class="balance-name">${name}</span>
                                    <span class="balance-amount-simple ${amount > 0 ? 'receive' : amount < 0 ? 'pay' : 'zero'}">
                                        ${amount < 0 ? '-' : ''}${formatCurrency(Math.abs(amount))}
                                    </span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
            }
        }

        function updateExpensesTab() {
            if (!currentGroup || !currentGroup.expenses) return;

            const detailsExpensesList = document.getElementById('detailsExpensesList');
            const detailsNoExpenses = document.getElementById('detailsNoExpenses');
            const detailsTotal = document.getElementById('detailsTotalExpensesAmount');

            if (currentGroup.expenses.length === 0) {
                if (detailsExpensesList) detailsExpensesList.style.display = 'none';
                if (detailsNoExpenses) detailsNoExpenses.style.display = 'block';
                if (detailsTotal) detailsTotal.textContent = formatCurrency(0);
                return;
            }

            // Get only participants (names), not member IDs
            const participants = Array.isArray(currentGroup.participants) ? currentGroup.participants : [];
            
            // Calculate each person's share (split amount, not what they paid) - only for participants
            const shareByPerson = {};
            participants.forEach(participant => {
                shareByPerson[participant] = 0;
            });

            currentGroup.expenses.forEach(expense => {
                const amount = parseFloat(expense.amount || 0);
                // Filter splitBetween to only include participants (names, not IDs)
                const splitBetween = (expense.splitBetween || []).filter(name => 
                    participants.includes(name) && 
                    !name.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) &&
                    !name.match(/^user\d+$/i) &&
                    !name.match(/^[a-zA-Z]+\d+$/)
                );
                if (splitBetween.length === 0) return; // Skip if no valid participants
                
                // Handle unequal splits
                let perPerson = amount / splitBetween.length;
                if (expense.splitType === 'custom' && expense.customAmounts) {
                    perPerson = 0; // Will be set per person below
                }

                // Each participant who is part of the split gets their share
                splitBetween.forEach(participant => {
                    if (shareByPerson[participant] !== undefined) {
                        if (expense.splitType === 'custom' && expense.customAmounts && expense.customAmounts[participant] !== undefined) {
                            // Use custom amount for this person
                            shareByPerson[participant] += expense.customAmounts[participant];
                        } else {
                            // Use equal split
                            shareByPerson[participant] += perPerson;
                        }
                    }
                });
            });

            // Convert to array and sort by amount (highest first)
            const shareEntries = Object.entries(shareByPerson)
                .map(([name, amount]) => ({ name, amount }))
                .sort((a, b) => b.amount - a.amount);

            if (detailsExpensesList) {
                detailsExpensesList.style.display = 'block';
                detailsExpensesList.innerHTML = shareEntries.map(({ name, amount }) => `
                    <div class="expense-item-simple">
                        <div class="expense-item-content">
                            <span class="expense-name">${name}</span>
                            <span class="expense-amount-simple">${formatCurrency(amount)}</span>
                        </div>
                    </div>
                `).join('');
            }

            if (detailsNoExpenses) detailsNoExpenses.style.display = 'none';
            if (detailsTotal) detailsTotal.textContent = formatCurrency(currentGroup.totalExpenses || 0);
        }

        // ========================================
        // INITIALIZATION
        // ========================================
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('Group Detail Page Loading...');
            console.log('Current URL:', window.location.href);
            console.log('URL search:', window.location.search);

            // REQUIRED: Initialize Supabase - app won't work without it
            if (typeof window.initializeSupabase !== 'function') {
                showNotification('Supabase initialization failed. Please check your configuration.', 'error');
                document.body.innerHTML = '<div style="padding: 2rem; text-align: center;"><h1>Configuration Error</h1><p>Supabase is required but not configured. Please check js/config.js</p></div>';
                return;
            }

            const supabaseInitialized = window.initializeSupabase();
            if (!supabaseInitialized) {
                showNotification('Supabase initialization failed. Please check your connection and configuration.', 'error');
                document.body.innerHTML = '<div style="padding: 2rem; text-align: center;"><h1>Connection Error</h1><p>Cannot connect to Supabase. Please check your internet connection and js/config.js configuration.</p></div>';
                return;
            }

            // Wait a moment for Supabase to fully initialize
            await new Promise(resolve => setTimeout(resolve, 500));

            if (!window.supabaseClient) {
                showNotification('Supabase client not available. Please refresh the page.', 'error');
                return;
            }

            // CRITICAL: Initialize user session first
            const userData = localStorage.getItem('spliteasy_current_user');
            if (userData) {
                try {
                    window.currentUser = JSON.parse(userData);
                    console.log('User session restored for group detail:', window.currentUser.name);
                } catch (error) {
                    console.error('Failed to parse user data:', error);
                    // Don't redirect immediately - might be a shared link
                }
            } else {
                console.warn('No user session found - will redirect to signup if accessing shared link');
            }

            // Get group ID from URL with enhanced debugging
            console.log('Parsing URL parameters...');
            const urlParams = new URLSearchParams(window.location.search);
            console.log('URL Params object:', urlParams);
            console.log('All URL param entries:', [...urlParams.entries()]);

            const groupId = urlParams.get('id');
            console.log('Group ID from URL:', groupId);

            if (groupId) {
                console.log('Group ID found, proceeding with load...');
                window.currentGroupId = groupId;
                currentGroupId = groupId;

                // If accessing via shared link and no user, redirect to signup first
                // Check this BEFORE trying to load the group
                if (!window.currentUser) {
                    console.log('No user logged in, redirecting to signup/login...');
                    const returnUrl = encodeURIComponent(window.location.href);
                    showNotification('Please sign up or log in to access this group', 'info');
                    setTimeout(() => {
                        window.location.href = `index.html?returnTo=${returnUrl}`;
                    }, 500);
                    return;
                }

                loadGroupData(groupId);
            } else {
                console.error('No group ID provided in URL');
                console.log('Available URL params:', window.location.search);

                showNotification('No group ID provided', 'error');
                setTimeout(() => {
                    window.location.href = 'index.html';
                }, 2000);
            }

            // Initialize real-time sync for group detail page
            if (window.currentUser && typeof window.startRealtimeSync === 'function') {
                console.log('Scheduling real-time sync initialization...');
                setTimeout(() => {
                    window.startRealtimeSync();
                    // After starting real-time, wait a bit then check if it's working
                    setTimeout(() => {
                        if (!isRealtimeSyncActive()) {
                            console.log('Real-time sync not active - starting auto-refresh fallback');
                            startAutoRefresh();
                        } else {
                            console.log('Real-time sync is active - auto-refresh not needed');
                        }
                    }, 3000);
                }, 2000); // Give time for group to load
            } else {
                console.log('Real-time sync not initialized - starting auto-refresh fallback');
                // Start auto-refresh as fallback if real-time sync is not available
                startAutoRefresh();
            }

            // Listen for real-time status changes
            window.onRealtimeStatusChange = function(isActive) {
                if (isActive) {
                    console.log('‚úÖ Real-time sync became active - stopping auto-refresh');
                    stopAutoRefresh();
                } else {
                    console.log('‚ùå Real-time sync failed - starting auto-refresh fallback');
                    startAutoRefresh();
                }
            };
        });

        // ========================================
        // AUTOMATIC REFRESH (POLLING) - FALLBACK FOR REAL-TIME SYNC
        // ========================================
        
        // Check if real-time sync is active and working
        function isRealtimeSyncActive() {
            return window.splitEasySync?.realtimeSubscription && 
                   window.splitEasySync?.realtimeActive === true;
        }

        // Start automatic refresh polling (only as fallback when real-time sync is not working)
        function startAutoRefresh() {
            // Stop any existing interval
            stopAutoRefresh();
            
            // Only start if we have a current group
            if (!currentGroupId && !currentGroup) {
                console.log('No group loaded, skipping auto-refresh');
                return;
            }

            // Check if real-time sync is active - if so, don't start auto-refresh
            if (isRealtimeSyncActive()) {
                console.log('‚úÖ Real-time sync is active - skipping auto-refresh');
                return;
            }

            console.log('üîÑ Starting smart auto-refresh (fallback mode - real-time sync not available)');
            
            // Store last known updated_at timestamp to detect changes
            let lastKnownUpdatedAt = currentGroup?.updatedAt || currentGroup?.updated_at || null;
            let lastKnownExpenseCount = currentGroup?.expenses?.length || 0;
            
            // Poll every 15 seconds (less frequent since this is just a fallback)
            autoRefreshInterval = setInterval(async () => {
                // Check if real-time sync became active - if so, stop auto-refresh
                if (isRealtimeSyncActive()) {
                    console.log('‚úÖ Real-time sync is now active - stopping auto-refresh');
                    stopAutoRefresh();
                    return;
                }

                // Skip if page is hidden (user switched tabs/apps)
                if (document.hidden) {
                    return;
                }

                // Skip if we don't have a group ID
                const groupIdToCheck = currentGroupId || (currentGroup && (currentGroup.id || currentGroup.supabaseId));
                if (!groupIdToCheck || !window.supabaseClient) {
                    return;
                }

                try {
                    // STEP 1: Lightweight check - only fetch updated_at timestamp and expense count
                    // This is much faster than fetching the entire group
                    const { data: groupMeta, error: metaError } = await window.supabaseClient
                        .from('groups')
                        .select('updated_at, id')
                        .eq('id', groupIdToCheck)
                        .maybeSingle();

                    if (metaError || !groupMeta) {
                        console.warn('Auto-refresh: Could not check group metadata');
                        return;
                    }

                    // Also check if expenses count changed (lightweight query)
                    const { count: expenseCount, error: expenseError } = await window.supabaseClient
                        .from('expenses')
                        .select('*', { count: 'exact', head: true })
                        .eq('group_id', groupIdToCheck);

                    const currentExpenseCount = expenseCount || 0;
                    const currentUpdatedAt = groupMeta.updated_at;

                    // STEP 2: Only proceed if there are actual changes
                    const hasChanges = 
                        currentUpdatedAt !== lastKnownUpdatedAt ||
                        currentExpenseCount !== lastKnownExpenseCount;

                    if (!hasChanges) {
                        // No changes detected, skip full fetch
                        return;
                    }

                    console.log('üîÑ Auto-refresh (fallback): Changes detected, fetching full group data');

                    // STEP 3: Only now fetch the full group data (expensive operation)
                    if (typeof window.fetchGroupFromDatabase === 'function') {
                        const updatedGroup = await window.fetchGroupFromDatabase(groupIdToCheck);
                        
                        if (updatedGroup && currentGroup) {
                            // Update last known values
                            lastKnownUpdatedAt = updatedGroup.updatedAt || updatedGroup.updated_at;
                            lastKnownExpenseCount = updatedGroup.expenses?.length || 0;
                            
                            console.log('üîÑ Auto-refresh (fallback): Group updated, refreshing display');
                            
                            // Update current group
                            currentGroup = updatedGroup;
                            window.currentGroup = updatedGroup;
                            
                            // Update local storage
                            const localGroups = loadFromLocalStorage();
                            const groupIndex = localGroups.findIndex(g => 
                                g.id === groupIdToCheck || 
                                g.supabaseId === groupIdToCheck ||
                                (g.id === currentGroup.id) ||
                                (g.supabaseId === currentGroup.supabaseId)
                            );
                            if (groupIndex !== -1) {
                                localGroups[groupIndex] = updatedGroup;
                                saveGroupsToLocalStorage(localGroups);
                            }
                            
                            // Update UI
                            await updateGroupDisplay();
                        }
                    }
                } catch (error) {
                    console.warn('Auto-refresh error (will retry on next interval):', error);
                    // Don't show notification for polling errors to avoid spam
                }
            }, 15000); // 15 seconds (fallback mode - less frequent)

            // Stop polling when page becomes hidden
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    console.log('Page hidden, pausing auto-refresh');
                } else {
                    console.log('Page visible, auto-refresh continues');
                }
            });
        }

        // Stop automatic refresh polling
        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                console.log('üõë Stopped automatic refresh');
            }
        }

        // Stop polling when page is unloaded
        window.addEventListener('beforeunload', () => {
            stopAutoRefresh();
        });

        // ========================================
        // CORE FUNCTIONS - FIXED FOR EXPENSE PERSISTENCE
        // ========================================

        // Helper function to get user name from ID
        // Checks localStorage first, then tries to fetch from database
        async function getUserNameFromId(userId) {
            if (!userId) return userId;
            
            // Check if it's the current user
            if (window.currentUser && window.currentUser.id === userId) {
                return window.currentUser.name;
            }
            
            // Check localStorage for previous users
            try {
                const previousUsers = JSON.parse(localStorage.getItem('spliteasy_previous_users') || '[]');
                const user = previousUsers.find(u => u.id === userId);
                if (user) return user.name;
            } catch (e) {
                console.warn('Error reading previous users:', e);
            }
            
            // Try to fetch from database
            if (window.supabaseClient) {
                try {
                    const { data, error } = await window.supabaseClient
                        .from('users')
                        .select('name')
                        .eq('id', userId)
                        .single();
                    
                    if (!error && data) {
                        return data.name;
                    }
                } catch (e) {
                    console.warn('Error fetching user name from database:', e);
                }
            }
            
            // Fallback: return ID if name not found
            return userId;
        }

        // Helper function to get all people in a group (registered members + participants)
        // Converts member IDs to names for display
        async function getAllGroupPeople(group) {
            if (!group) return [];
            
            // Get registered user IDs (members) and convert to names
            const memberIds = Array.isArray(group.members) ? group.members : [];
            const memberNames = await Promise.all(
                memberIds.map(async (id) => {
                    // Check if it's already a name (for backward compatibility)
                    if (typeof id === 'string' && !id.includes('user') && id.length < 20) {
                        return id; // Likely already a name
                    }
                    return await getUserNameFromId(id);
                })
            );
            
            // Get non-registered participant names
            const participants = Array.isArray(group.participants) ? group.participants : [];
            
            // Combine and remove duplicates
            const allPeople = [...memberNames, ...participants];
            return [...new Set(allPeople)]; // Remove duplicates
        }

        // Synchronous version for immediate use (uses cached data only)
        function getAllGroupPeopleSync(group) {
            if (!group) return [];
            
            // Get registered user IDs (members)
            const memberIds = Array.isArray(group.members) ? group.members : [];
            const memberNames = memberIds.map(id => {
                // Check if it's the current user
                if (window.currentUser && window.currentUser.id === id) {
                    return window.currentUser.name;
                }
                
                // Check if it's already a name (for backward compatibility)
                if (typeof id === 'string' && !id.includes('user') && id.length < 20) {
                    return id; // Likely already a name
                }
                
                // Try to get from localStorage
                try {
                    const previousUsers = JSON.parse(localStorage.getItem('spliteasy_previous_users') || '[]');
                    const user = previousUsers.find(u => u.id === id);
                    if (user) return user.name;
                } catch (e) {
                    // Ignore errors
                }
                
                // Fallback: return ID
                return id;
            });
            
            // Get non-registered participant names
            const participants = Array.isArray(group.participants) ? group.participants : [];
            
            // Combine and remove duplicates
            const allPeople = [...memberNames, ...participants];
            return [...new Set(allPeople)];
        }

        // FIXED: Enhanced loadGroupData - Supabase first
        async function loadGroupData(groupId) {
            console.log('Loading group data for ID:', groupId);

            // Check if user is logged in (required for accessing groups)
            if (!window.currentUser) {
                console.log('No user logged in, redirecting to signup/login...');
                const returnUrl = encodeURIComponent(window.location.href);
                showNotification('Please sign up or log in to access this group', 'info');
                setTimeout(() => {
                    window.location.href = `index.html?returnTo=${returnUrl}`;
                }, 500);
                return;
            }

            // REQUIRED: Load from Supabase first
            if (!window.supabaseClient) {
                showNotification('Supabase not available. Please check your connection.', 'error');
                // Fallback to localStorage cache (only if user is logged in)
                const groups = loadFromLocalStorage();
                const foundGroup = groups.find(g => g.id === groupId);
            if (foundGroup) {
                    currentGroup = foundGroup;
                    window.currentGroup = foundGroup;
                    await updateGroupDisplay();
                    showNotification('Using cached data. Some features may be limited.', 'warning');
                    return;
                } else {
                    showNotification('Group not found. Please check your connection.', 'error');
                    setTimeout(() => window.location.href = 'index.html', 2000);
                return;
                }
            }

            try {
                // Check if this is a shared link (UUID format) FIRST
                const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                const isSharedLink = uuidRegex.test(groupId);
                
                console.log('Group ID format check:', { groupId, isSharedLink });
                
                // If it's a shared link, skip the normal fetch and go straight to direct fetch
                if (isSharedLink) {
                    console.log('Detected shared link (UUID format), fetching directly from database...');
                    try {
                        // Try to fetch the group directly from Supabase without membership check
                        const { data: directGroup, error: directError } = await window.supabaseClient
                            .from('groups')
                            .select('*')
                            .eq('id', groupId)
                            .maybeSingle();
                        
                        if (directError) {
                            console.error('Error fetching group directly:', directError);
                            throw new Error(`Database error: ${directError.message}`);
                        }
                        
                        if (directGroup) {
                            console.log('Group found via shared link:', directGroup);
                            
                            // Ensure schema is detected
                            if (typeof window.detectDatabaseSchema === 'function') {
                                await window.detectDatabaseSchema();
                            }
                            
                            // Get schema mappings - check multiple possible locations
                            let schemaMapping = null;
                            if (typeof window.SCHEMA_MAPPING !== 'undefined') {
                                schemaMapping = window.SCHEMA_MAPPING;
                            } else if (typeof window.splitEasySync !== 'undefined' && window.splitEasySync.SCHEMA_MAPPING) {
                                schemaMapping = window.splitEasySync.SCHEMA_MAPPING;
                            } else {
                                // Fallback: try to access from shared-sync.js scope
                                // If not available, use default snake_case column names
                                console.warn('SCHEMA_MAPPING not found, using default column names');
                            }
                            
                            const expenseSchema = schemaMapping?.expenses || {};
                            const groupSchema = schemaMapping?.groups || {};
                            
                            // Fetch expenses for this group
                            const groupIdColumn = expenseSchema.groupId || 'group_id';
                            const { data: expenses, error: expensesError } = await window.supabaseClient
                                .from('expenses')
                                .select('*')
                                .eq(groupIdColumn, groupId)
                                .order(expenseSchema.createdAt || 'created_at', { ascending: false });
                            
                            if (expensesError) {
                                console.warn('Error fetching expenses:', expensesError);
                            }
                            
                                // Handle members array (registered user IDs) - might be JSONB string
                            let members = directGroup[groupSchema.members] || directGroup.members || [];
                            if (typeof members === 'string') {
                                try {
                                    members = JSON.parse(members);
                                } catch (e) {
                                    console.warn('Failed to parse members JSON:', e);
                                    members = [];
                                }
                            }
                            if (!Array.isArray(members)) {
                                members = [];
                            }
                            
                            // Handle participants array (non-registered member names) - might be JSONB string
                            let participants = directGroup[groupSchema.participants] || directGroup.participants || [];
                            if (typeof participants === 'string') {
                                try {
                                    participants = JSON.parse(participants);
                                } catch (e) {
                                    console.warn('Failed to parse participants JSON:', e);
                                    participants = [];
                                }
                            }
                            if (!Array.isArray(participants)) {
                                participants = [];
                            }
                            
                            // Structure the group data properly
                            const structuredGroup = {
                                id: directGroup[groupSchema.id] || directGroup.id,
                                supabaseId: directGroup[groupSchema.id] || directGroup.id,
                                name: directGroup[groupSchema.name] || directGroup.name,
                                members: members,  // Registered user IDs only
                                participants: participants,  // Non-registered member names
                                expenses: (expenses || []).map(exp => ({
                                    id: exp[expenseSchema.id] || exp.id,
                                    name: exp[expenseSchema.description] || exp.description || exp.name,
                                    amount: parseFloat(exp[expenseSchema.amount] || exp.amount || 0),
                                    paidBy: exp[expenseSchema.paidBy] || exp.paid_by || exp.paidby,
                                    splitBetween: exp[expenseSchema.splitBetween] || exp.split_between || [],
                                    date: exp[expenseSchema.createdAt] || exp.created_at || exp.createdat,
                                    perPersonAmount: exp[expenseSchema.perPersonAmount] || exp.per_person_amount || 0,
                                    splitType: exp[expenseSchema.splitType] || exp.split_type || 'equal',
                                    customAmounts: exp[expenseSchema.customAmounts] || exp.custom_amounts || null,
                                    supabaseId: exp[expenseSchema.id] || exp.id
                                })),
                                totalExpenses: 0,
                                createdAt: directGroup[groupSchema.createdAt] || directGroup.created_at || directGroup.createdat,
                                createdBy: directGroup[groupSchema.createdBy] || directGroup.created_by || directGroup.createdby
                            };
                            
                            // Calculate total expenses
                            structuredGroup.totalExpenses = structuredGroup.expenses.reduce((sum, exp) => sum + parseFloat(exp.amount || 0), 0);
                            
                            // Join user to group
                            console.log('Joining user to group...');
                            try {
                                await joinGroupFromSharedLink(structuredGroup, groupId);
                            } catch (joinError) {
                                console.warn('Error joining group (continuing anyway):', joinError);
                                // Continue even if join fails - user can still view the group
                            }
                            
                            // Set as current group and display
                            currentGroup = structuredGroup;
                            window.currentGroup = structuredGroup;
                            
                            // Save to localStorage
                            const localGroups = loadFromLocalStorage();
                            const existingIndex = localGroups.findIndex(g => g.id === groupId || g.supabaseId === groupId);
                            if (existingIndex >= 0) {
                                localGroups[existingIndex] = structuredGroup;
                            } else {
                                localGroups.push(structuredGroup);
                            }
                            saveGroupsToLocalStorage(localGroups);
                            
                            // Check if user was already a member BEFORE joining
                            const groupMembersBeforeJoin = structuredGroup.members || [];
                            const wasAlreadyMember = groupMembersBeforeJoin.includes(window.currentUser.id) ||
                                                    groupMembersBeforeJoin.some(m => m && String(m).toLowerCase() === String(window.currentUser.id).toLowerCase());
                            
                            // Only join if not already a member
                            let actuallyJoined = false;
                            if (!wasAlreadyMember && typeof window.joinUserToGroup === 'function') {
                                const joinResult = await window.joinUserToGroup(groupId, window.currentUser.id);
                                if (joinResult && (typeof joinResult === 'object' ? joinResult.wasNewMember : true)) {
                                    actuallyJoined = true;
                                }
                            }
                            
                            await updateGroupDisplay();
                            
                            // Start auto-refresh now that group is loaded
                            startAutoRefresh();
                            
                            // Only show notification if user actually joined (was not already a member)
                            if (actuallyJoined) {
                                showNotification('Joined group successfully!', 'success');
                            }
                            return; // IMPORTANT: Return here to prevent falling through to error handler
                        } else {
                            console.log('Group not found in database with ID:', groupId);
                            // Continue to normal fetch flow below
                        }
                    } catch (shareError) {
                        console.error('Error processing shared link group:', shareError);
                        console.error('Share error details:', {
                            message: shareError.message,
                            stack: shareError.stack
                        });
                        // Don't throw here, let it fall through to normal fetch
                    }
                }
                
                // Normal flow: try to fetch group (checks membership)
                if (typeof window.fetchGroupFromDatabase !== 'function') {
                    throw new Error('fetchGroupFromDatabase function not available');
                }

                console.log('Fetching group using normal method (checks membership)...');
                const fetchedGroup = await window.fetchGroupFromDatabase(groupId);

                if (!fetchedGroup) {
                    // Group not found - try localStorage cache as fallback
                    const groups = loadFromLocalStorage();
                    const cachedGroup = groups.find(g => g.id === groupId || g.supabaseId === groupId);
                    if (cachedGroup) {
                    currentGroup = cachedGroup;
                    window.currentGroup = cachedGroup;
                    await updateGroupDisplay();
                    showNotification('Using cached data. Please check your connection.', 'warning');
                        return;
                    }
                    
                    // If it's a shared link, show a more helpful message
                    if (isSharedLink) {
                        showNotification('Group not found. The link may be invalid or the group was deleted.', 'error');
                    } else {
                        showNotification('Group not found. Please check your connection.', 'error');
                    }
                    setTimeout(() => window.location.href = 'index.html', 2000);
                    return;
                }

                // Cache in localStorage
                const localGroups = loadFromLocalStorage();
                const existingIndex = localGroups.findIndex(g => g.id === groupId);
                if (existingIndex >= 0) {
                    localGroups[existingIndex] = fetchedGroup;
                } else {
                localGroups.push(fetchedGroup);
                }
                saveGroupsToLocalStorage(localGroups);

                // Set as current group
                currentGroup = fetchedGroup;
                window.currentGroup = fetchedGroup;
                currentGroupId = groupId; // Ensure currentGroupId is set
                await updateGroupDisplay();

                // Start auto-refresh now that group is loaded
                startAutoRefresh();

                showNotification('Group loaded successfully', 'success');
                return;
            } catch (error) {
                console.error('Failed to load group from Supabase:', error);
                
                // Fallback to localStorage cache
                const groups = loadFromLocalStorage();
                const foundGroup = groups.find(g => g.id === groupId);
                if (foundGroup) {
                    currentGroup = foundGroup;
                    window.currentGroup = foundGroup;
                    await updateGroupDisplay();
                    showNotification('Using cached data. Some features may be limited.', 'warning');
                    return;
                }
                
                // If still not found, show error
                showNotification('Failed to load group. Please check your connection.', 'error');
                setTimeout(() => window.location.href = 'index.html', 2000);
                return;
            }

            // Group not found locally - try to fetch from database
            console.log('Group not found locally, checking database...');
            
            // If no user is logged in, redirect to signup/login
            if (!window.currentUser) {
                console.log('No user logged in, redirecting to signup/login...');
                const returnUrl = encodeURIComponent(window.location.href);
                window.location.href = `index.html?returnTo=${returnUrl}`;
                return;
            }
            
            try {
                // Check if Supabase is available
                if (!window.supabaseClient) {
                    console.warn('Supabase not available, trying to initialize...');
                    if (typeof window.initializeSupabase === 'function') {
                        window.initializeSupabase();
                        // Wait a bit for initialization
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }

                // Fetch group from database
                if (typeof window.fetchGroupFromDatabase !== 'function') {
                    throw new Error('Database functions not available. Please check your internet connection.');
                }

                if (!window.supabaseClient) {
                    throw new Error('Database connection not available. Please check your internet connection.');
                }

                const fetchedGroup = await window.fetchGroupFromDatabase(groupId);

                if (!fetchedGroup) {
                    showNotification('Group not found. The link may be invalid or the group was deleted.', 'error');
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 3000);
                    return;
                }

                // User is logged in, automatically join the group
                console.log('User logged in, automatically joining group:', fetchedGroup.name);
                await joinGroupFromSharedLink(fetchedGroup, groupId);

            } catch (error) {
                console.error('Failed to load group from share link:', error);
                const errorMessage = error.message || 'Unknown error';
                
                // More helpful error messages
                if (errorMessage.includes('connection') || errorMessage.includes('network') || errorMessage.includes('fetch')) {
                    showNotification('Connection error. Please check your internet connection and try again.', 'error');
                } else if (errorMessage.includes('not available')) {
                    showNotification('Database service unavailable. Please try again later.', 'error');
                } else {
                    showNotification('Failed to load group. Please check your connection and try again.', 'error');
                }
                
                // Don't redirect immediately - give user time to read error
                setTimeout(() => {
                    window.location.href = 'index.html';
                }, 4000);
            }
        }

        // FIXED: Enhanced localStorage functions
        function loadFromLocalStorage() {
            try {
                const data = localStorage.getItem('spliteasy_groups');
                const groups = data ? JSON.parse(data) : [];
                console.log('LoadFromLocalStorage: Found', groups.length, 'groups');
                return groups;
            } catch (error) {
                console.error('Error loading from localStorage:', error);
                return [];
            }
        }

        // Optimized save function with batching and cache invalidation
        // Create a debounced version that works even if debounce isn't loaded yet
        let saveGroupsToLocalStorageTimeout = null;
        let lastGroupsToSave = null;
        
        function saveGroupsToLocalStorage(groups) {
            // Store the groups to save
            lastGroupsToSave = groups;
            
            // Clear existing timeout if debounce isn't available
            if (saveGroupsToLocalStorageTimeout) {
                clearTimeout(saveGroupsToLocalStorageTimeout);
            }

            const saveFunction = () => {
                const groupsToSave = lastGroupsToSave;
                if (!groupsToSave) return;
                
                try {
                    console.log('Saving', groupsToSave.length, 'groups to localStorage');

                // Ensure each group has proper structure and calculated totals
                    groupsToSave.forEach((group) => {
                    // Ensure expenses array exists
                    if (!group.expenses) {
                        group.expenses = [];
                    }

                    // Calculate total expenses
                    if (group.expenses.length > 0) {
                        group.totalExpenses = group.expenses.reduce((sum, exp) => sum + parseFloat(exp.amount || 0), 0);

                        // Ensure each expense has proper structure
                        group.expenses.forEach(expense => {
                            if (expense.splitBetween && expense.splitBetween.length > 0) {
                                expense.perPersonAmount = parseFloat(expense.amount || 0) / expense.splitBetween.length;
                            }
                        });
                    } else {
                        group.totalExpenses = 0;
                    }
                });

                    // Use batchLocalStorageOperation if available, otherwise direct save
                    if (typeof batchLocalStorageOperation === 'function') {
                        batchLocalStorageOperation(() => {
                            localStorage.setItem('spliteasy_groups', JSON.stringify(groupsToSave));
                            if (typeof invalidateGroupsCache === 'function') {
                                invalidateGroupsCache();
                            }
                            console.log('Successfully saved groups to localStorage');
                        });
                    } else {
                        localStorage.setItem('spliteasy_groups', JSON.stringify(groupsToSave));
                        console.log('Successfully saved groups to localStorage');
                    }

            } catch (error) {
                    console.error('Failed to save to localStorage:', error);
                showNotification('Failed to save data locally', 'error');
                }
            };

            // Use debounce if available, otherwise use setTimeout
            if (typeof debounce === 'function') {
                if (!window._debouncedSaveGroupsToLocalStorage) {
                    window._debouncedSaveGroupsToLocalStorage = debounce(saveFunction, 300);
                }
                window._debouncedSaveGroupsToLocalStorage();
            } else {
                // Fallback: simple debounce with setTimeout
                saveGroupsToLocalStorageTimeout = setTimeout(saveFunction, 300);
            }
        }

        // FIXED: Critical updateGroupInStorage function
        function updateGroupInStorage() {
            console.log('Updating group in storage for group ID:', currentGroupId);

            if (!currentGroup || !currentGroupId) {
                console.error('No currentGroup or currentGroupId to update');
                return;
            }

            try {
                // Load all groups from localStorage
                const allGroups = loadFromLocalStorage();
                console.log('Found', allGroups.length, 'total groups in storage');

                // Find the index of the current group
                const groupIndex = allGroups.findIndex(g => g.id === currentGroupId);

                if (groupIndex !== -1) {
                    console.log('üìç Found group at index', groupIndex, 'in localStorage');
                    console.log('Updating with', currentGroup.expenses?.length || 0, 'expenses');

                    // CRITICAL: Replace the entire group object with current data
                    allGroups[groupIndex] = { ...currentGroup };

                    // Update both global references
                    window.currentGroup = currentGroup;

                    // Save back to localStorage
                    saveGroupsToLocalStorage(allGroups);

                    console.log('Successfully updated group in storage');
                } else {
                    console.error('Group not found in localStorage for update');
                    // Group doesn't exist, add it
                    allGroups.push(currentGroup);
                    saveGroupsToLocalStorage(allGroups);
                    console.log('Added new group to storage');
                }
            } catch (error) {
                console.error('Failed to update group in storage:', error);
            }
        }

        // Helper function to update group display
        async function updateGroupDisplay() {
            if (!currentGroup) {
                console.error('No currentGroup to display');
                return;
            }

            console.log('üé® Updating display for group:', currentGroup.name);
            console.log('Group has', currentGroup.expenses?.length || 0, 'expenses to display');

            safeUpdateElement('groupName', currentGroup.name);
            
            // Get creator name for display
            const creatorId = currentGroup.createdBy || currentGroup.created_by;
            const creatorName = creatorId === window.currentUser?.id 
                ? window.currentUser.name 
                : await getUserNameFromId(creatorId);
            
            // Check if group is pending deletion
            const pendingDeletion = currentGroup.pendingDeletion || currentGroup.pending_deletion;
            // Count only actual participant names (filter out IDs)
            const participants = Array.isArray(currentGroup.participants) ? currentGroup.participants : [];
            const memberIds = Array.isArray(currentGroup.members) ? currentGroup.members : [];
            const participantCount = participants.filter(p => {
                if (typeof p !== 'string') return false;
                // Filter out registered member IDs
                if (memberIds.includes(p)) {
                    return false; // This is a registered member ID, not a participant
                }
                // Filter out UUIDs and IDs with "user" pattern
                if (p.includes('user') || p.length > 30 || /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(p)) {
                    return false; // This looks like an ID
                }
                return true; // This looks like a participant name
            }).length;
            
            let metaText = `${participantCount} members ‚Ä¢ ${currentGroup.expenses?.length || 0} expenses ‚Ä¢ Created by ${creatorName} ‚Ä¢ ${formatDate(currentGroup.createdAt)}`;
            
            if (pendingDeletion) {
                metaText += ' ‚Ä¢ ‚ö†Ô∏è Pending Deletion';
                // Show deletion confirmation modal if user is a member (not creator)
                if (window.currentUser && creatorId !== window.currentUser.id) {
                    showDeletionConfirmationModal();
                }
            }
            
            safeUpdateElement('groupMeta', metaText);
            safeUpdateElement('totalExpensesAmount', formatCurrency(currentGroup.totalExpenses || 0));

            // Show/hide delete button based on creator
            const deleteBtn = document.getElementById('deleteBtn');
            if (deleteBtn) {
                if (window.currentUser && creatorId === window.currentUser.id && !pendingDeletion) {
                    deleteBtn.style.display = 'inline-block';
                } else {
                    deleteBtn.style.display = 'none';
                }
            }

            displayExpenses();
            calculateBalances();
        }

        // Show deletion confirmation modal for members
        function showDeletionConfirmationModal() {
            const modal = document.getElementById('deletionConfirmationModal');
            const message = document.getElementById('deletionMessage');
            const status = document.getElementById('deletionStatus');
            
            if (!currentGroup || !window.currentUser) return;
            
            const creatorId = currentGroup.createdBy || currentGroup.created_by;
            const creatorName = currentGroup.createdBy === window.currentUser?.id 
                ? window.currentUser.name 
                : getUserNameFromId(currentGroup.createdBy || currentGroup.created_by);
            
            // Get confirmation status
            const confirmedBy = currentGroup.deletionConfirmedBy || currentGroup.deletion_confirmed_by || [];
            const members = currentGroup.members || [];
            const allConfirmed = members.every(m => confirmedBy.includes(m));
            
            if (message) {
                message.textContent = `${creatorName} has requested to delete this group.`;
            }
            
            if (status) {
                if (allConfirmed) {
                    status.textContent = 'All members have confirmed. Group will be deleted.';
                    status.style.color = '#dc3545';
                } else {
                    const confirmedCount = confirmedBy.length;
                    status.textContent = `${confirmedCount} of ${members.length} members confirmed deletion.`;
                    status.style.color = '#ffc107';
                }
            }
            
            if (modal) modal.style.display = 'block';
        }

        function closeDeletionConfirmationModal() {
            const modal = document.getElementById('deletionConfirmationModal');
            if (modal) modal.style.display = 'none';
        }

        async function handleConfirmDeletion() {
            if (!currentGroup || !window.currentUser) return;
            
            try {
                if (typeof window.confirmGroupDeletion === 'function') {
                    await window.confirmGroupDeletion(currentGroup.id || currentGroup.supabaseId);
                    showNotification('You confirmed deletion. You will be removed from the group.', 'info');
                    closeDeletionConfirmationModal();
                    
                    // Reload group or redirect
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 2000);
                } else {
                    throw new Error('Confirm deletion function not available');
                }
            } catch (error) {
                console.error('Failed to confirm deletion:', error);
                showNotification('Failed to confirm deletion. Please try again.', 'error');
            }
        }

        async function handleRestoreGroup() {
            if (!currentGroup || !window.currentUser) return;
            
            try {
                if (typeof window.restoreGroup === 'function') {
                    await window.restoreGroup(currentGroup.id || currentGroup.supabaseId);
                    showNotification('Group restoration requested. The creator will be notified.', 'success');
                    closeDeletionConfirmationModal();
                    
                    // Reload group to update status
                    await loadGroupData(currentGroup.id || currentGroup.supabaseId);
                } else {
                    throw new Error('Restore group function not available');
                }
            } catch (error) {
                console.error('Failed to restore group:', error);
                showNotification('Failed to restore group. Please try again.', 'error');
            }
        }

        // safeUpdateElement is now in shared-utils.js

        // FIXED: Enhanced displayExpenses with detailed logging
        function displayExpenses() {
            console.log('üé® DisplayExpenses called');
            console.log('Current group expenses:', currentGroup?.expenses?.length || 0);

            const expensesList = document.getElementById('expensesList');
            const noExpenses = document.getElementById('noExpenses');

            if (!currentGroup || !currentGroup.expenses || currentGroup.expenses.length === 0) {
                console.log('üì≠ No expenses to display');
                if (expensesList) expensesList.style.display = 'none';
                if (noExpenses) noExpenses.style.display = 'block';
                return;
            }

            console.log('Displaying', currentGroup.expenses.length, 'expenses');
            if (expensesList) expensesList.style.display = 'block';
            if (noExpenses) noExpenses.style.display = 'none';

            // Store all expenses for filtering
            if (allExpenses.length === 0 || allExpenses.length !== currentGroup.expenses.length) {
                allExpenses = [...currentGroup.expenses];
            }

            // Get only participants (names), not member IDs
            const participants = Array.isArray(currentGroup.participants) ? currentGroup.participants : [];
            
            // Helper function to filter out IDs and keep only participant names
            const filterToParticipants = (value) => {
                if (Array.isArray(value)) {
                    return value.filter(name => 
                        participants.includes(name) && 
                        !name.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) &&
                        !name.match(/^user\d+$/i) &&
                        !name.match(/^[a-zA-Z]+\d+$/)
                    );
                }
                if (typeof value === 'string') {
                    return participants.includes(value) && 
                           !value.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) &&
                           !value.match(/^user\d+$/i) &&
                           !value.match(/^[a-zA-Z]+\d+$/) ? value : null;
                }
                return null;
            };

            if (expensesList) {
                expensesList.innerHTML = currentGroup.expenses.map((expense, index) => {
                    console.log(`Expense ${index + 1}:`, expense.name, '-', formatCurrency(expense.amount));
                    const paidBy = filterToParticipants(expense.paidBy) || 'Unknown';
                    const splitBetween = filterToParticipants(expense.splitBetween || []);
                    const isCustomSplit = expense.splitType === 'custom' && expense.customAmounts;
                    
                    // Calculate per-person amount
                    let perPersonAmount = 0;
                    let perPersonHtml = '';
                    if (isCustomSplit && expense.customAmounts) {
                        // For custom splits, don't show per-person since it varies
                        perPersonHtml = '';
                    } else if (splitBetween.length > 0) {
                        // For equal splits, calculate per person
                        perPersonAmount = parseFloat(expense.amount || 0) / splitBetween.length;
                        perPersonHtml = `<div class="per-person-amount">${formatCurrency(perPersonAmount)} each</div>`;
                    }
                    
                    // For custom splits, show each person's amount
                    let splitBetweenText;
                    if (isCustomSplit) {
                        splitBetweenText = splitBetween.map(member => {
                            const amount = expense.customAmounts[member];
                            return amount !== undefined ? `${member} (${formatCurrency(amount)})` : member;
                        }).join(', ');
                    } else {
                        splitBetweenText = splitBetween.length > 0 ? splitBetween.join(', ') : 'Unknown';
                    }
                    
                    const splitLabel = isCustomSplit ? 'Custom split between' : 'Split between';
                    
                    return `
                        <div class="expense-item">
                            <div class="expense-content">
                                <h4>${expense.name}</h4>
                                <div class="expense-amount">${formatCurrency(expense.amount)}</div>
                                <div class="expense-meta">Paid by ${paidBy} ‚Ä¢ ${splitLabel} ${splitBetweenText}</div>
                                ${perPersonHtml}
                            </div>
                            <div class="expense-actions">
                                <button class="expense-action-btn edit" onclick="editExpense('${expense.id}')" title="Edit Expense">‚úé</button>
                                <button class="expense-action-btn delete" onclick="deleteExpense('${expense.id}')" title="Delete Expense">√ó</button>
                            </div>
                        </div>
                    `;
                }).join('');

                console.log('Expenses HTML generated and inserted');
            }
        }

        // Store original expenses for filtering
        let allExpenses = [];

        function filterExpenses() {
            const searchInput = document.getElementById('expenseSearchInput');
            const searchTerm = (searchInput?.value || '').toLowerCase().trim();
            
            if (!currentGroup || !currentGroup.expenses) return;
            
            // Restore from allExpenses if needed
            if (allExpenses.length === 0) {
                allExpenses = [...currentGroup.expenses];
            }
            
            if (!searchTerm) {
                currentGroup.expenses = [...allExpenses];
            } else {
                currentGroup.expenses = allExpenses.filter(expense => 
                    expense.name.toLowerCase().includes(searchTerm) ||
                    expense.paidBy.toLowerCase().includes(searchTerm) ||
                    (expense.splitBetween && expense.splitBetween.some(member => member.toLowerCase().includes(searchTerm)))
                );
            }
            
            displayExpenses();
            calculateBalances();
        }

        // FIXED: Enhanced Settlement System
        function calculateBalances() {
            const balancesList = document.getElementById('balancesList');

            if (!balancesList || !currentGroup || !currentGroup.expenses || currentGroup.expenses.length === 0) {
                if (balancesList) {
                    balancesList.innerHTML = '<p class="no-settlements">No expenses to calculate settlements</p>';
                }
                return;
            }

            // Get only participants (names), not member IDs
            const participants = Array.isArray(currentGroup.participants) ? currentGroup.participants : [];
            
            // Calculate individual balances using only participants
            const balances = {};
            participants.forEach(participant => {
                balances[participant] = 0;
            });

            currentGroup.expenses.forEach(expense => {
                const amount = parseFloat(expense.amount);
                // Filter splitBetween to only include participants (names, not IDs)
                const splitBetween = (expense.splitBetween || []).filter(name => 
                    participants.includes(name) && 
                    !name.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) &&
                    !name.match(/^user\d+$/i) &&
                    !name.match(/^[a-zA-Z]+\d+$/)
                );
                if (splitBetween.length === 0) return; // Skip if no valid participants
                
                // Handle unequal splits
                let perPerson = amount / splitBetween.length;
                if (expense.splitType === 'custom' && expense.customAmounts) {
                    perPerson = 0; // Will be set per person below
                }

                // Person who paid gets credited (only if they're a participant)
                if (participants.includes(expense.paidBy) && 
                    !expense.paidBy.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) &&
                    !expense.paidBy.match(/^user\d+$/i) &&
                    !expense.paidBy.match(/^[a-zA-Z]+\d+$/)) {
                    if (balances[expense.paidBy] !== undefined) {
                        balances[expense.paidBy] += amount;
                    }
                }

                // Everyone who shared the expense gets debited
                splitBetween.forEach(participant => {
                    if (balances[participant] !== undefined) {
                        if (expense.splitType === 'custom' && expense.customAmounts && expense.customAmounts[participant] !== undefined) {
                            // Use custom amount for this person
                            balances[participant] -= expense.customAmounts[participant];
                        } else {
                            // Use equal split
                            balances[participant] -= perPerson;
                        }
                    }
                });
            });

            // Get creditors and debtors
            const creditors = [];
            const debtors = [];

            Object.entries(balances).forEach(([member, amount]) => {
                if (Math.abs(amount) > 0.01) {
                    if (amount > 0) {
                        creditors.push({ name: member, amount: amount });
                    } else {
                        debtors.push({ name: member, amount: Math.abs(amount) });
                    }
                }
            });

            creditors.sort((a, b) => b.amount - a.amount);
            debtors.sort((a, b) => b.amount - a.amount);

            // Calculate optimal settlements
            const settlements = [];
            let i = 0, j = 0;

            while (i < creditors.length && j < debtors.length) {
                const creditor = creditors[i];
                const debtor = debtors[j];
                const settlementAmount = Math.min(creditor.amount, debtor.amount);

                settlements.push({
                    from: debtor.name,
                    to: creditor.name,
                    amount: settlementAmount
                });

                creditor.amount -= settlementAmount;
                debtor.amount -= settlementAmount;

                if (creditor.amount < 0.01) i++;
                if (debtor.amount < 0.01) j++;
            }

            // Display settlements
            if (settlements.length === 0) {
                balancesList.innerHTML = `
                    <div class="settlement-complete">
                        <div class="settlement-icon">‚úì</div>
                        <h4>All Settled Up!</h4>
                        <p>No payments needed - everyone is even!</p>
                    </div>
                `;
            } else {
                const settlementHTML = settlements.map(settlement => `
                    <div class="settlement-item-modern">
                        <div class="settlement-info">
                            <span class="settlement-from-name">${settlement.from}</span>
                            <span class="settlement-arrow-modern">‚Üí</span>
                            <span class="settlement-to-name">${settlement.to}</span>
                            </div>
                        <div class="settlement-amount-modern">${formatCurrency(settlement.amount)}</div>
                    </div>
                `).join('');

                balancesList.innerHTML = `
                    <div class="settlements-list-modern">
                        ${settlementHTML}
                    </div>
                `;
            }
        }

        // ========================================
        // ADD EXPENSE FUNCTIONS - FIXED
        // ========================================
        function showAddExpenseModal() {
            const modal = document.getElementById('addExpenseModal');
            const paidBySelect = document.getElementById('expensePaidBy');
            const splitGrid = document.getElementById('expenseSplitGrid');
            const splitTypeSelect = document.getElementById('expenseSplitType');
            const amountInput = document.getElementById('expenseAmount');
            const descriptionInput = document.getElementById('expenseDescription');

            if (modal) modal.style.display = 'block';

            // Reset split type to equal
            if (splitTypeSelect) {
                splitTypeSelect.value = 'equal';
                handleSplitTypeChange();
            }
            
            // Add real-time validation listeners
            if (amountInput) {
                amountInput.addEventListener('input', function() {
                    validateExpenseAmount(this);
                });
            }
            
            if (descriptionInput) {
                descriptionInput.addEventListener('input', function() {
                    const helpText = document.getElementById('expenseDescriptionHelp');
                    if (helpText) {
                        const remaining = 200 - this.value.length;
                        helpText.textContent = `${remaining} characters remaining`;
                        if (remaining < 20) {
                            helpText.style.color = 'var(--warning-color)';
                        } else if (remaining < 0) {
                            helpText.style.color = 'var(--danger-color)';
                        } else {
                            helpText.style.color = 'var(--text-secondary)';
                        }
                    }
                });
            }

            // Populate paid by dropdown - only participants (names), not member IDs
            if (paidBySelect && currentGroup) {
                const participants = Array.isArray(currentGroup.participants) ? currentGroup.participants : [];
                paidBySelect.innerHTML = '<option value="">Select who paid</option>' +
                    participants.map(participant => 
                        `<option value="${participant}">${participant}</option>`
                    ).join('');
            }

            // Populate split between grid - only participants (names), not member IDs
            if (splitGrid && currentGroup) {
                const participants = Array.isArray(currentGroup.participants) ? currentGroup.participants : [];
                splitGrid.innerHTML = participants.map(participant => 
                    `<div class="selectable-box selected" data-member="${participant}">
                        ${participant}
                    </div>`
                ).join('');
            }
        }

        // Handle split type change
        function handleSplitTypeChange() {
            const splitType = document.getElementById('expenseSplitType')?.value;
            const customContainer = document.getElementById('customAmountsContainer');
            const amountInput = document.getElementById('expenseAmount');
            
            if (splitType === 'custom') {
                if (customContainer) customContainer.style.display = 'block';
                updateCustomAmountsList();
                // Listen to amount changes
                if (amountInput) {
                    amountInput.addEventListener('input', updateCustomAmountsList);
                }
            } else {
                if (customContainer) customContainer.style.display = 'none';
                if (amountInput) {
                    amountInput.removeEventListener('input', updateCustomAmountsList);
                }
            }
        }

        // Update custom amounts list based on selected members
        function updateCustomAmountsList() {
            const selectedBoxes = document.querySelectorAll('#expenseSplitGrid .selectable-box.selected');
            const selectedMembers = Array.from(selectedBoxes).map(box => box.dataset.member);
            const amountInput = document.getElementById('expenseAmount');
            const totalAmount = parseFloat(amountInput?.value || 0);
            const customList = document.getElementById('customAmountsList');
            const totalDisplay = document.getElementById('customAmountsTotal');
            
            if (!customList) return;
            
            // Calculate equal split as default
            const equalAmount = selectedMembers.length > 0 ? totalAmount / selectedMembers.length : 0;
            
            customList.innerHTML = selectedMembers.map(member => {
                const inputId = `customAmount-${member.replace(/\s+/g, '-')}`;
                return `
                    <div class="custom-amount-item">
                        <label for="${inputId}">${member}</label>
                        <input 
                            type="number" 
                            id="${inputId}" 
                            class="custom-amount-input" 
                            data-member="${member}"
                            value="${equalAmount.toFixed(2)}" 
                            step="0.01" 
                            min="0"
                            max="10000000"
                            oninput="validateCustomAmount(this); updateCustomAmountsTotal()"
                        >
                    </div>
                `;
            }).join('');
            
            updateCustomAmountsTotal();
        }

        // Validate expense amount input
        function validateExpenseAmount(input) {
            const value = parseFloat(input.value);
            const helpText = input.id === 'expenseAmount' 
                ? document.getElementById('expenseAmountHelp')
                : document.getElementById('editExpenseAmountHelp');
            
            if (!helpText) return;
            
            if (input.value === '' || isNaN(value)) {
                helpText.textContent = 'Enter amount between ‚Çπ0.01 and ‚Çπ10,000,000';
                helpText.style.color = 'var(--text-secondary)';
                input.setCustomValidity('');
                return;
            }
            
            if (value <= 0) {
                helpText.textContent = 'Amount must be greater than ‚Çπ0.00';
                helpText.style.color = 'var(--danger-color)';
                input.setCustomValidity('Amount must be greater than ‚Çπ0.00');
                input.classList.add('invalid');
                return;
            }
            
            if (value > 10000000) {
                helpText.textContent = 'Amount cannot exceed ‚Çπ10,000,000';
                helpText.style.color = 'var(--danger-color)';
                input.setCustomValidity('Amount cannot exceed ‚Çπ10,000,000');
                input.classList.add('invalid');
                return;
            }
            
            // Valid amount
            helpText.textContent = 'Enter amount between ‚Çπ0.01 and ‚Çπ10,000,000';
            helpText.style.color = 'var(--text-secondary)';
            input.setCustomValidity('');
            input.classList.remove('invalid');
        }
        
        // Validate custom amount input
        function validateCustomAmount(input) {
            const value = parseFloat(input.value);
            
            if (input.value === '' || isNaN(value)) {
                input.setCustomValidity('');
                input.classList.remove('invalid');
                return;
            }
            
            if (value < 0) {
                input.setCustomValidity('Amount cannot be negative');
                input.classList.add('invalid');
                return;
            }
            
            if (value > 10000000) {
                input.setCustomValidity('Amount cannot exceed ‚Çπ10,000,000');
                input.classList.add('invalid');
                return;
            }
            
            // Valid amount
            input.setCustomValidity('');
            input.classList.remove('invalid');
        }

        // Update custom amounts total
        function updateCustomAmountsTotal() {
            const customInputs = document.querySelectorAll('.custom-amount-input');
            let total = 0;
            customInputs.forEach(input => {
                total += parseFloat(input.value || 0);
            });
            
            const totalDisplay = document.getElementById('customAmountsTotal');
            if (totalDisplay) {
                totalDisplay.textContent = `Total: ${formatCurrency(total)}`;
                const amountInput = document.getElementById('expenseAmount');
                const expectedTotal = parseFloat(amountInput?.value || 0);
                
                if (Math.abs(total - expectedTotal) > 0.01) {
                    totalDisplay.style.color = 'var(--danger-color)';
                } else {
                    totalDisplay.style.color = 'var(--success-color)';
                }
            }
        }

        function closeAddExpenseModal() {
            const modal = document.getElementById('addExpenseModal');
            if (modal) modal.style.display = 'none';

            // Reset form
            ['expenseDescription', 'expenseAmount', 'expensePaidBy'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.value = '';
            });
            
            // Reset split type
            const splitTypeSelect = document.getElementById('expenseSplitType');
            if (splitTypeSelect) splitTypeSelect.value = 'equal';
            const customContainer = document.getElementById('customAmountsContainer');
            if (customContainer) customContainer.style.display = 'none';
        }

        function selectAllExpenseMembers() {
            document.querySelectorAll('#expenseSplitGrid .selectable-box').forEach(box => {
                box.classList.add('selected');
            });
        }

        function clearAllExpenseMembers() {
            document.querySelectorAll('#expenseSplitGrid .selectable-box').forEach(box => {
                box.classList.remove('selected');
            });
        }

        // FIXED: Critical addExpense function with proper persistence
        async function addExpense() {
            console.log('Adding new expense...');

            const description = document.getElementById('expenseDescription')?.value.trim();
            const amount = document.getElementById('expenseAmount')?.value;
            const paidBy = document.getElementById('expensePaidBy')?.value;
            const splitType = document.getElementById('expenseSplitType')?.value || 'equal';
            const selectedBoxes = document.querySelectorAll('#expenseSplitGrid .selectable-box.selected');
            const splitBetween = Array.from(selectedBoxes).map(box => box.dataset.member);

            // Validation
            if (!description || !amount || !paidBy || splitBetween.length === 0) {
                showNotification('Please fill all fields', 'error');
                return;
            }
            
            // Validate description length
            if (description.length > 200) {
                showNotification('Description cannot exceed 200 characters', 'error');
                return;
            }
            
            // Validate amount
            const amountValue = parseFloat(amount);
            if (isNaN(amountValue) || amountValue <= 0) {
                showNotification('Amount must be greater than ‚Çπ0.00', 'error');
                return;
            }
            
            if (amountValue > 10000000) {
                showNotification('Amount cannot exceed ‚Çπ10,000,000', 'error');
                return;
            }
            
            // Validate amount has at most 2 decimal places (using string check to avoid floating-point issues)
            const amountStr = amount.toString();
            const decimalIndex = amountStr.indexOf('.');
            if (decimalIndex !== -1 && amountStr.length - decimalIndex - 1 > 2) {
                showNotification('Amount can have at most 2 decimal places', 'error');
                return;
            }

            // Check if user is logged in
            if (!window.currentUser) {
                showNotification('Please log in to add expenses', 'error');
                window.location.href = 'index.html';
                return;
            }

            // Handle custom amounts
            let customAmounts = {};
            let perPersonAmount = parseFloat(amount) / splitBetween.length;
            
            if (splitType === 'custom') {
                const customInputs = document.querySelectorAll('.custom-amount-input');
                let total = 0;
                let hasInvalidAmount = false;
                
                customInputs.forEach(input => {
                    const member = input.dataset.member;
                    const value = parseFloat(input.value || 0);
                    
                    // Validate individual custom amounts
                    if (isNaN(value) || value < 0) {
                        showNotification(`Invalid amount for ${member}. Amount must be 0 or greater.`, 'error');
                        hasInvalidAmount = true;
                        return;
                    }
                    
                    if (value > 10000000) {
                        showNotification(`Amount for ${member} cannot exceed ‚Çπ10,000,000`, 'error');
                        hasInvalidAmount = true;
                        return;
                    }
                    
                    customAmounts[member] = value;
                    total += value;
                });
                
                if (hasInvalidAmount) {
                    return;
                }
                
                // Validate total matches expense amount
                const expectedTotal = parseFloat(amount);
                if (Math.abs(total - expectedTotal) > 0.01) {
                    showNotification(`Custom amounts total (${formatCurrency(total)}) must equal expense amount (${formatCurrency(expectedTotal)})`, 'error');
                    return;
                }
                
                // Calculate average for perPersonAmount (for backward compatibility)
                perPersonAmount = total / splitBetween.length;
            }

            const newExpense = {
                id: generateId(),
                name: description,
                amount: parseFloat(amount),
                paidBy: paidBy,
                splitBetween: splitBetween,
                date: new Date().toISOString(),
                perPersonAmount: perPersonAmount,
                splitType: splitType,
                customAmounts: splitType === 'custom' ? customAmounts : undefined
            };

            console.log('üìù New expense created:', newExpense);

            // CRITICAL: Ensure expenses array exists
            if (!currentGroup.expenses) {
                currentGroup.expenses = [];
                console.log('Initialized expenses array');
            }

            // Add expense to current group
            currentGroup.expenses.push(newExpense);
            console.log('Added expense. Group now has', currentGroup.expenses.length, 'expenses');

            // Recalculate total
            currentGroup.totalExpenses = (currentGroup.totalExpenses || 0) + parseFloat(amount);
            console.log('New total expenses:', formatCurrency(currentGroup.totalExpenses));

            try {
                // Ensure user is set before syncing
                if (!window.currentUser) {
                    const userData = localStorage.getItem('spliteasy_current_user');
                    if (userData) {
                        window.currentUser = JSON.parse(userData);
                    } else {
                        // Create guest user if none exists
                        const guestUserId = 'guest_' + Date.now();
                        window.currentUser = {
                            id: guestUserId,
                            name: 'Guest',
                            createdAt: new Date().toISOString(),
                            isGuest: true
                        };
                        localStorage.setItem('spliteasy_current_user', JSON.stringify(window.currentUser));
                    }
                }

                // REQUIRED: Save to Supabase first
                if (!window.supabaseClient) {
                    throw new Error('Supabase client not available');
                }

                if (typeof window.syncExpenseToDatabase !== 'function') {
                    throw new Error('syncExpenseToDatabase function not available');
                }

                showNotification('Saving expense to cloud...', 'info');
                await window.syncExpenseToDatabase(newExpense, currentGroup.id);
                
                // CRITICAL: Save to storage cache
            updateGroupInStorage();

            // Update UI
            displayExpenses();
            calculateBalances();
            safeUpdateElement('totalExpensesAmount', formatCurrency(currentGroup.totalExpenses));

            // Close modal
            closeAddExpenseModal();

                showNotification('Expense added successfully!', 'success');
                
                // Reload group from Supabase to ensure sync
                await loadGroupData(currentGroup.id);
                } catch (error) {
                console.error('Failed to save expense:', error);
                showNotification('Failed to save expense. Please check your connection.', 'error');
                }
        }

        // ========================================
        // EDIT EXPENSE FUNCTIONS - FIXED
        // ========================================
        function editExpense(expenseId) {
            const expense = currentGroup.expenses.find(e => e.id === expenseId);
            if (!expense) return;

            editingExpenseId = expenseId;

            // Populate form
            const descriptionInput = document.getElementById('editExpenseDescription');
            const amountInput = document.getElementById('editExpenseAmount');
            
            if (descriptionInput) descriptionInput.value = expense.name;
            if (amountInput) amountInput.value = expense.amount;
            
            // Set split type
            const splitTypeSelect = document.getElementById('editExpenseSplitType');
            const splitType = expense.splitType || 'equal';
            if (splitTypeSelect) {
                splitTypeSelect.value = splitType;
            }
            
            // Add real-time validation listeners
            if (amountInput) {
                amountInput.addEventListener('input', function() {
                    validateExpenseAmount(this);
                });
            }
            
            if (descriptionInput) {
                descriptionInput.addEventListener('input', function() {
                    const helpText = document.getElementById('editExpenseDescriptionHelp');
                    if (helpText) {
                        const remaining = 200 - this.value.length;
                        helpText.textContent = `${remaining} characters remaining`;
                        if (remaining < 20) {
                            helpText.style.color = 'var(--warning-color)';
                        } else if (remaining < 0) {
                            helpText.style.color = 'var(--danger-color)';
                        } else {
                            helpText.style.color = 'var(--text-secondary)';
                        }
                    }
                });
            }

            // Get only participants (names), not member IDs
            const participants = Array.isArray(currentGroup.participants) ? currentGroup.participants : [];
            
            // Filter expense.paidBy and expense.splitBetween to only include participants (names, not IDs)
            const expensePaidBy = participants.includes(expense.paidBy) && 
                                 !expense.paidBy.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) &&
                                 !expense.paidBy.match(/^user\d+$/i) &&
                                 !expense.paidBy.match(/^[a-zA-Z]+\d+$/) 
                                 ? expense.paidBy : '';
            
            const expenseSplitBetween = (expense.splitBetween || []).filter(name => 
                participants.includes(name) && 
                !name.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) &&
                !name.match(/^user\d+$/i) &&
                !name.match(/^[a-zA-Z]+\d+$/)
            );

            const paidBySelect = document.getElementById('editExpensePaidBy');
            paidBySelect.innerHTML = '<option value="">Select who paid</option>' +
                participants.map(participant => 
                    `<option value="${participant}" ${participant === expensePaidBy ? 'selected' : ''}>${participant}</option>`
                ).join('');

            // Populate split between grid - only participants
            const splitGrid = document.getElementById('editExpenseSplitGrid');
            splitGrid.innerHTML = participants.map(participant => 
                `<div class="selectable-box ${expenseSplitBetween.includes(participant) ? 'selected' : ''}" data-member="${participant}">
                    ${participant}
                </div>`
            ).join('');
            
            // Handle split type change (this will now properly load custom amounts)
            handleEditSplitTypeChange();

            document.getElementById('editExpenseModal').style.display = 'block';
        }
        
        // Handle edit split type change
        function handleEditSplitTypeChange() {
            const splitType = document.getElementById('editExpenseSplitType')?.value;
            const customContainer = document.getElementById('editCustomAmountsContainer');
            const amountInput = document.getElementById('editExpenseAmount');
            
            if (splitType === 'custom') {
                if (customContainer) customContainer.style.display = 'block';
                updateEditCustomAmountsList();
                // Listen to amount changes
                if (amountInput) {
                    amountInput.addEventListener('input', updateEditCustomAmountsList);
                }
            } else {
                if (customContainer) customContainer.style.display = 'none';
                if (amountInput) {
                    amountInput.removeEventListener('input', updateEditCustomAmountsList);
                }
            }
        }
        
        // Update edit custom amounts list
        function updateEditCustomAmountsList() {
            const selectedBoxes = document.querySelectorAll('#editExpenseSplitGrid .selectable-box.selected');
            const selectedMembers = Array.from(selectedBoxes).map(box => box.dataset.member);
            const amountInput = document.getElementById('editExpenseAmount');
            const totalAmount = parseFloat(amountInput?.value || 0);
            const customList = document.getElementById('editCustomAmountsList');
            
            if (!customList) return;
            
            // Check if we're editing an expense with custom amounts
            let existingCustomAmounts = {};
            if (editingExpenseId) {
                const editingExpense = currentGroup.expenses.find(e => e.id === editingExpenseId);
                if (editingExpense && editingExpense.splitType === 'custom' && editingExpense.customAmounts) {
                    existingCustomAmounts = editingExpense.customAmounts;
                }
            }
            
            // Calculate equal split as default for members without custom amounts
            const equalAmount = selectedMembers.length > 0 ? totalAmount / selectedMembers.length : 0;
            
            customList.innerHTML = selectedMembers.map(member => {
                const inputId = `editCustomAmount-${member.replace(/\s+/g, '-')}`;
                // Use existing custom amount if available, otherwise use equal split
                const memberAmount = existingCustomAmounts[member] !== undefined 
                    ? existingCustomAmounts[member] 
                    : equalAmount;
                return `
                    <div class="custom-amount-item">
                        <label for="${inputId}">${member}</label>
                        <input 
                            type="number" 
                            id="${inputId}" 
                            class="custom-amount-input" 
                            data-member="${member}"
                            value="${memberAmount.toFixed(2)}" 
                            step="0.01" 
                            min="0"
                            max="10000000"
                            oninput="validateCustomAmount(this); updateEditCustomAmountsTotal()"
                        >
                    </div>
                `;
            }).join('');
            
            updateEditCustomAmountsTotal();
        }
        
        // Update edit custom amounts total
        function updateEditCustomAmountsTotal() {
            const customInputs = document.querySelectorAll('#editCustomAmountsList .custom-amount-input');
            let total = 0;
            customInputs.forEach(input => {
                total += parseFloat(input.value || 0);
            });
            
            const totalDisplay = document.getElementById('editCustomAmountsTotal');
            if (totalDisplay) {
                totalDisplay.textContent = `Total: ${formatCurrency(total)}`;
                const amountInput = document.getElementById('editExpenseAmount');
                const expectedTotal = parseFloat(amountInput?.value || 0);
                
                if (Math.abs(total - expectedTotal) > 0.01) {
                    totalDisplay.style.color = 'var(--danger-color)';
                } else {
                    totalDisplay.style.color = 'var(--success-color)';
                }
            }
        }

        function closeEditExpenseModal() {
            document.getElementById('editExpenseModal').style.display = 'none';
            editingExpenseId = null;
        }

        function selectAllEditExpenseMembers() {
            document.querySelectorAll('#editExpenseSplitGrid .selectable-box').forEach(box => {
                box.classList.add('selected');
            });
        }

        function clearAllEditExpenseMembers() {
            document.querySelectorAll('#editExpenseSplitGrid .selectable-box').forEach(box => {
                box.classList.remove('selected');
            });
        }

        // FIXED: Save expense changes with proper persistence
        async function saveExpenseChanges() {
            if (!editingExpenseId) return;

            const description = document.getElementById('editExpenseDescription')?.value.trim();
            const amount = document.getElementById('editExpenseAmount')?.value;
            const paidBy = document.getElementById('editExpensePaidBy')?.value;
            const splitType = document.getElementById('editExpenseSplitType')?.value || 'equal';
            const selectedBoxes = document.querySelectorAll('#editExpenseSplitGrid .selectable-box.selected');
            const splitBetween = Array.from(selectedBoxes).map(box => box.dataset.member);

            // Validation
            if (!description || !amount || !paidBy || splitBetween.length === 0) {
                showNotification('Please fill all fields', 'error');
                return;
            }
            
            // Validate description length
            if (description.length > 200) {
                showNotification('Description cannot exceed 200 characters', 'error');
                return;
            }
            
            // Validate amount
            const amountValue = parseFloat(amount);
            if (isNaN(amountValue) || amountValue <= 0) {
                showNotification('Amount must be greater than ‚Çπ0.00', 'error');
                return;
            }
            
            if (amountValue > 10000000) {
                showNotification('Amount cannot exceed ‚Çπ10,000,000', 'error');
                return;
            }
            
            // Validate amount has at most 2 decimal places (using string check to avoid floating-point issues)
            const amountStr = amount.toString();
            const decimalIndex = amountStr.indexOf('.');
            if (decimalIndex !== -1 && amountStr.length - decimalIndex - 1 > 2) {
                showNotification('Amount can have at most 2 decimal places', 'error');
                return;
            }

            // Handle custom amounts
            let customAmounts = {};
            let perPersonAmount = parseFloat(amount) / splitBetween.length;
            
            if (splitType === 'custom') {
                const customInputs = document.querySelectorAll('#editCustomAmountsList .custom-amount-input');
                let total = 0;
                let hasInvalidAmount = false;
                
                customInputs.forEach(input => {
                    const member = input.dataset.member;
                    const value = parseFloat(input.value || 0);
                    
                    // Validate individual custom amounts
                    if (isNaN(value) || value < 0) {
                        showNotification(`Invalid amount for ${member}. Amount must be 0 or greater.`, 'error');
                        hasInvalidAmount = true;
                        return;
                    }
                    
                    if (value > 10000000) {
                        showNotification(`Amount for ${member} cannot exceed ‚Çπ10,000,000`, 'error');
                        hasInvalidAmount = true;
                        return;
                    }
                    
                    customAmounts[member] = value;
                    total += value;
                });
                
                if (hasInvalidAmount) {
                    return;
                }
                
                // Validate total matches expense amount
                const expectedTotal = parseFloat(amount);
                if (Math.abs(total - expectedTotal) > 0.01) {
                    showNotification(`Custom amounts total (${formatCurrency(total)}) must equal expense amount (${formatCurrency(expectedTotal)})`, 'error');
                    return;
                }
                
                perPersonAmount = total / splitBetween.length;
            }

            const expenseIndex = currentGroup.expenses.findIndex(e => e.id === editingExpenseId);
            if (expenseIndex !== -1) {
                const oldAmount = parseFloat(currentGroup.expenses[expenseIndex].amount);
                const newAmount = parseFloat(amount);

                // Preserve the expense ID and supabaseId to ensure update, not create
                const existingExpense = currentGroup.expenses[expenseIndex];
                currentGroup.expenses[expenseIndex] = {
                    ...existingExpense,
                    id: existingExpense.id, // Preserve original ID
                    supabaseId: existingExpense.supabaseId || existingExpense.id, // Preserve supabaseId or use id
                    name: description,
                    amount: newAmount,
                    paidBy: paidBy,
                    splitBetween: splitBetween,
                    perPersonAmount: perPersonAmount,
                    splitType: splitType,
                    customAmounts: splitType === 'custom' ? customAmounts : undefined
                };

                // Update total
                currentGroup.totalExpenses = (currentGroup.totalExpenses || 0) - oldAmount + newAmount;

                // REQUIRED: Save to Supabase first
                if (!window.supabaseClient) {
                    throw new Error('Supabase client not available');
                }

                if (typeof window.syncExpenseToDatabase !== 'function') {
                    throw new Error('syncExpenseToDatabase function not available');
                }

                showNotification('Updating expense in cloud...', 'info');
                await window.syncExpenseToDatabase(currentGroup.expenses[expenseIndex], currentGroup.id);
                
                // CRITICAL: Save to storage cache
                updateGroupInStorage();

                // Update UI
                displayExpenses();
                calculateBalances();
                safeUpdateElement('totalExpensesAmount', formatCurrency(currentGroup.totalExpenses));

                showNotification('Expense updated successfully!', 'success');
                
                // Reload group from Supabase to ensure sync
                await loadGroupData(currentGroup.id);

                closeEditExpenseModal();
                showNotification('Expense updated successfully!', 'success');
            }
        }

        // FIXED: Delete expense with proper persistence
        async function deleteExpense(expenseId) {
            const expense = currentGroup.expenses.find(e => e.id === expenseId);
            if (!expense) {
                console.error('Expense not found:', expenseId);
                return;
            }

            if (!confirm(`Are you sure you want to delete the expense "${expense.name}"?`)) return;

            try {
                // REQUIRED: Delete from Supabase first
                if (!window.supabaseClient) {
                    throw new Error('Supabase client not available');
                }

                if (typeof window.deleteExpenseFromDatabase !== 'function') {
                    throw new Error('deleteExpenseFromDatabase function not available');
                }

                showNotification('Deleting expense from cloud...', 'info');
                await window.deleteExpenseFromDatabase(expenseId);

                // Delete from local data
                const expenseIndex = currentGroup.expenses.findIndex(e => e.id === expenseId);
                if (expenseIndex !== -1) {
                    const deletedExpense = currentGroup.expenses[expenseIndex];
                    currentGroup.expenses.splice(expenseIndex, 1);
                    currentGroup.totalExpenses = Math.max(0, (currentGroup.totalExpenses || 0) - parseFloat(deletedExpense.amount));

                    // CRITICAL: Save changes to cache
                    updateGroupInStorage();

                    // Update UI
                    displayExpenses();
                    calculateBalances();
                    safeUpdateElement('totalExpensesAmount', formatCurrency(currentGroup.totalExpenses));

                    showNotification('Expense deleted successfully!', 'success');
                }
            } catch (error) {
                console.error('Delete expense failed:', error);
                showNotification(`Failed to delete expense: ${error.message}`, 'error');
            }
        }

        // ========================================
        // GROUP FUNCTIONS
        // ========================================
        let snapshotCanvas = null;
        let snapshotBlob = null;

        // Get settlements data for snapshot (mirrors updateBalancesUI logic)
        function getSettlementsData() {
            if (!currentGroup || !currentGroup.expenses || currentGroup.expenses.length === 0) {
                return [];
            }

            // Get only participants (names), not member IDs - same as updateBalancesUI
            const participants = Array.isArray(currentGroup.participants) ? currentGroup.participants : [];
            
            if (participants.length === 0) return [];

            // Initialize balances
            const balances = {};
            participants.forEach(p => balances[p] = 0);

            // Calculate balances from expenses - same logic as updateBalancesUI
            currentGroup.expenses.forEach(expense => {
                const amount = parseFloat(expense.amount);
                // Filter splitBetween to only include participants (names, not IDs)
                const splitBetween = (expense.splitBetween || []).filter(name => 
                    participants.includes(name) && 
                    !name.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) &&
                    !name.match(/^user\d+$/i) &&
                    !name.match(/^[a-zA-Z]+\d+$/)
                );
                
                if (splitBetween.length === 0) return;

                // Handle unequal splits
                let perPerson = amount / splitBetween.length;
                if (expense.splitType === 'custom' && expense.customAmounts) {
                    perPerson = 0;
                }

                // Credit the payer (only if they're a participant)
                if (participants.includes(expense.paidBy) && 
                    !expense.paidBy.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) &&
                    !expense.paidBy.match(/^user\d+$/i) &&
                    !expense.paidBy.match(/^[a-zA-Z]+\d+$/)) {
                    if (balances[expense.paidBy] !== undefined) {
                        balances[expense.paidBy] += amount;
                    }
                }

                // Debit each person's share
                splitBetween.forEach(participant => {
                    if (balances[participant] !== undefined) {
                        if (expense.splitType === 'custom' && expense.customAmounts && expense.customAmounts[participant] !== undefined) {
                            balances[participant] -= expense.customAmounts[participant];
                        } else {
                            balances[participant] -= perPerson;
                        }
                    }
                });
            });

            // Get creditors and debtors
            const creditors = [];
            const debtors = [];

            Object.entries(balances).forEach(([member, amount]) => {
                if (Math.abs(amount) > 0.01) {
                    if (amount > 0) {
                        creditors.push({ name: member, amount: amount });
                    } else {
                        debtors.push({ name: member, amount: Math.abs(amount) });
                    }
                }
            });

            creditors.sort((a, b) => b.amount - a.amount);
            debtors.sort((a, b) => b.amount - a.amount);

            // Calculate optimal settlements
            const settlements = [];
            let i = 0, j = 0;

            while (i < creditors.length && j < debtors.length) {
                const creditor = creditors[i];
                const debtor = debtors[j];
                const settlementAmount = Math.min(creditor.amount, debtor.amount);

                settlements.push({
                    from: debtor.name,
                    to: creditor.name,
                    amount: settlementAmount
                });

                creditor.amount -= settlementAmount;
                debtor.amount -= settlementAmount;

                if (creditor.amount < 0.01) i++;
                if (debtor.amount < 0.01) j++;
            }

            return settlements;
        }

        // Base URL for sharing (always use Vercel URL for cleaner links)
        const SHARE_BASE_URL = 'https://spliteasy-skyv.vercel.app';

        async function shareGroup() {
            const modal = document.getElementById('shareModal');
            const shareLink = document.getElementById('shareLink');
            const groupId = new URLSearchParams(window.location.search).get('id');
            const url = `${SHARE_BASE_URL}/group-detail?id=${groupId}`;

            if (shareLink) shareLink.value = url;
            if (modal) modal.style.display = 'block';
            
            // Generate snapshot preview
            await generateSnapshotPreview();
        }

        async function generateSnapshotPreview() {
            const previewContainer = document.getElementById('snapshotPreview');
            
            if (!previewContainer) return;
            
            previewContainer.innerHTML = '<p class="snapshot-loading">Generating preview...</p>';
            
            try {
                // Get settlements data
                const settlements = getSettlementsData();
                const groupName = currentGroup?.name || 'Group';
                const totalAmount = settlements.reduce((sum, s) => sum + s.amount, 0);
                
                // Build a beautiful custom snapshot element
                const snapshotEl = document.createElement('div');
                snapshotEl.style.cssText = `
                    width: 380px;
                    background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
                    border-radius: 16px;
                    padding: 24px;
                    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.08);
                `;
                
                // Header with gradient
                const header = document.createElement('div');
                header.style.cssText = `
                    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                    margin: -24px -24px 20px -24px;
                    padding: 20px 24px;
                    border-radius: 16px 16px 0 0;
                `;
                header.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="color: #ffffff; font-size: 20px; font-weight: 700;">${escapeHtml(groupName)}</div>
                        <div style="color: rgba(255,255,255,0.9); font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;">SplitEasy</div>
                    </div>
                `;
                snapshotEl.appendChild(header);
                
                // Settlements title
                const title = document.createElement('div');
                title.style.cssText = 'font-size: 14px; font-weight: 600; color: #64748b; margin-bottom: 16px; text-transform: uppercase; letter-spacing: 0.5px;';
                title.textContent = 'Settlements Needed';
                snapshotEl.appendChild(title);
                
                // Settlements list
                if (settlements.length === 0) {
                    const noSettlements = document.createElement('div');
                    noSettlements.style.cssText = 'text-align: center; padding: 20px; color: #16a34a; font-size: 16px;';
                    noSettlements.innerHTML = '<div style="font-size: 32px; margin-bottom: 8px;">‚úì</div>All settled up!';
                    snapshotEl.appendChild(noSettlements);
                } else {
                    const list = document.createElement('div');
                    list.style.cssText = 'display: flex; flex-direction: column; background: #ffffff; border-radius: 12px; border: 1px solid #e2e8f0; overflow: hidden;';
                    
                    settlements.forEach(s => {
                        const item = document.createElement('div');
                        item.style.cssText = `
                            display: flex;
                            align-items: center;
                            justify-content: space-between;
                            padding: 16px;
                            background: #ffffff;
                            border-left: 3px solid #e53e3e;
                            border-bottom: 1px solid #f1f5f9;
                        `;
                        item.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                                <span style="color: #e53e3e; font-weight: 600; font-size: 16px;">${escapeHtml(s.from)}</span>
                                <span style="color: #94a3b8; font-size: 16px; opacity: 0.6;">‚Üí</span>
                                <span style="color: #16a34a; font-weight: 600; font-size: 16px;">${escapeHtml(s.to)}</span>
                            </div>
                            <div style="font-weight: 700; color: #0f172a; font-size: 16px; font-feature-settings: 'tnum'; text-align: right; min-width: 90px;">${formatCurrency(s.amount)}</div>
                        `;
                        list.appendChild(item);
                    });
                    snapshotEl.appendChild(list);
                    
                    // Total
                    const totalDiv = document.createElement('div');
                    totalDiv.style.cssText = `
                        margin-top: 16px;
                        padding-top: 16px;
                        border-top: 2px dashed #e2e8f0;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    `;
                    totalDiv.innerHTML = `
                        <span style="font-size: 16px; color: #64748b; font-weight: 600; flex: 1;">Total to settle</span>
                        <span style="font-size: 16px; font-weight: 700; color: #16a34a; text-align: right; min-width: 90px;">${formatCurrency(totalAmount)}</span>
                    `;
                    snapshotEl.appendChild(totalDiv);
                }
                
                // Temporarily add to DOM (hidden)
                snapshotEl.style.position = 'absolute';
                snapshotEl.style.left = '-9999px';
                snapshotEl.style.top = '0';
                document.body.appendChild(snapshotEl);
                
                // Generate canvas
                snapshotCanvas = await html2canvas(snapshotEl, {
                    backgroundColor: null,
                    scale: 2,
                    useCORS: true,
                    logging: false
                });
                
                // Remove element
                document.body.removeChild(snapshotEl);
                
                // Convert to blob for sharing
                snapshotCanvas.toBlob(blob => {
                    snapshotBlob = blob;
                }, 'image/png');
                
                // Show preview (smaller version)
                const previewImg = document.createElement('img');
                previewImg.src = snapshotCanvas.toDataURL('image/png');
                previewImg.className = 'snapshot-image';
                previewImg.alt = 'Settlements snapshot preview';
                
                previewContainer.innerHTML = '';
                previewContainer.appendChild(previewImg);
                
            } catch (error) {
                console.error('Error generating snapshot:', error);
                previewContainer.innerHTML = '<p class="snapshot-error">Could not generate preview</p>';
            }
        }

        async function shareWithSnapshot() {
            const groupId = new URLSearchParams(window.location.search).get('id');
            const url = `${SHARE_BASE_URL}/group-detail?id=${groupId}`;
            const groupName = currentGroup?.name || 'Group';
            const safeGroupName = groupName.replace(/[^a-zA-Z0-9\s]/g, '').substring(0, 30);
            
            // Check if snapshot is ready
            if (!snapshotCanvas) {
                showNotification('Generating snapshot...', 'info');
                await generateSnapshotPreview();
                // Wait a bit for blob to be ready
                await new Promise(resolve => setTimeout(resolve, 500));
                if (!snapshotCanvas) {
                    showNotification('Could not generate snapshot. Please try again.', 'error');
                    return;
                }
            }
            
            // Ensure blob is ready
            if (!snapshotBlob) {
                await new Promise((resolve) => {
                    snapshotCanvas.toBlob(blob => {
                        snapshotBlob = blob;
                        resolve();
                    }, 'image/png');
                });
            }
            
            // Detect device type
            const ua = navigator.userAgent;
            const isAndroid = /Android/i.test(ua);
            const isIOS = /iPhone|iPad|iPod/i.test(ua);
            const isMobile = isAndroid || isIOS || /webOS|BlackBerry|IEMobile|Opera Mini/i.test(ua);
            
            console.log('Share attempt - Device:', { isAndroid, isIOS, isMobile, hasShare: !!navigator.share, hasCanShare: !!navigator.canShare });
            
            // Strategy 1: Try native file sharing (best experience)
            if (isMobile && navigator.share && snapshotBlob) {
                const fileName = `${safeGroupName}-settlements.png`;
                
                try {
                    const file = new File([snapshotBlob], fileName, { type: 'image/png' });
                    
                    // Check if file sharing is supported
                    if (navigator.canShare && navigator.canShare({ files: [file] })) {
                        // Try sharing file only (most compatible)
                        await navigator.share({ files: [file] });
                        showNotification('Shared successfully!', 'success');
                        closeShareModal();
                        return;
                    }
                } catch (error) {
                    if (error.name === 'AbortError') return; // User cancelled
                    console.warn('File share failed:', error.message);
                }
                
                // Strategy 2: Try sharing just URL/text (fallback for devices that don't support file sharing)
                try {
                    const textShareData = { 
                        title: safeGroupName,
                        text: `${safeGroupName} Settlements`,
                        url: url 
                    };
                    
                    if (!navigator.canShare || navigator.canShare(textShareData)) {
                        await navigator.share(textShareData);
                        // Also save image to device
                        await saveImageToDevice(safeGroupName);
                        showNotification('Link shared! Image saved to device.', 'success');
                        closeShareModal();
                        return;
                    }
                } catch (error) {
                    if (error.name === 'AbortError') return;
                    console.warn('Text share failed:', error.message);
                }
            }
            
            // Strategy 3: Fallback - Save image and copy link
            const imageSaved = await saveImageToDevice(safeGroupName);
            const linkCopied = await copyToClipboard(url);
            
            if (imageSaved && linkCopied) {
                showNotification('Image saved & link copied!', 'success');
            } else if (imageSaved) {
                showNotification('Image saved! Long-press to copy link: ' + url, 'success');
            } else if (linkCopied) {
                showNotification('Link copied! Long-press image to save.', 'success');
            } else {
                // Final fallback - show manual instructions
                showManualShareInstructions(url);
            }
        }
        
        // Save image to device (works on all devices)
        async function saveImageToDevice(groupName) {
            try {
                const dataUrl = snapshotCanvas.toDataURL('image/png');
                
                // Method 1: Try download attribute (works on most browsers)
                const link = document.createElement('a');
                link.download = `${groupName}-settlements.png`;
                link.href = dataUrl;
                link.style.display = 'none';
                document.body.appendChild(link);
                
                // For iOS Safari, we need to open in new tab
                const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
                const isSafari = /Safari/i.test(navigator.userAgent) && !/Chrome/i.test(navigator.userAgent);
                
                if (isIOS && isSafari) {
                    // iOS Safari: Open image in new tab for manual save
                    window.open(dataUrl, '_blank');
                    document.body.removeChild(link);
                    return true;
                }
                
                link.click();
                document.body.removeChild(link);
                return true;
            } catch (error) {
                console.error('Save image failed:', error);
                return false;
            }
        }
        
        // Copy text to clipboard (with fallbacks)
        async function copyToClipboard(text) {
            try {
                // Modern API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                    return true;
                }
                
                // Fallback: execCommand
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                const success = document.execCommand('copy');
                document.body.removeChild(textarea);
                return success;
            } catch (error) {
                console.error('Copy to clipboard failed:', error);
                return false;
            }
        }
        
        // Show manual share instructions as last resort
        function showManualShareInstructions(url) {
            const modal = document.getElementById('shareModal');
            if (modal) {
                const modalBody = modal.querySelector('.modal-body') || modal;
                const instructions = document.createElement('div');
                instructions.className = 'manual-share-instructions';
                instructions.style.cssText = 'background: #fef3c7; padding: 12px; border-radius: 8px; margin-top: 12px; font-size: 14px;';
                instructions.innerHTML = `
                    <p style="margin: 0 0 8px 0; font-weight: 600; color: #92400e;">üì± Manual Share Steps:</p>
                    <ol style="margin: 0; padding-left: 20px; color: #78350f;">
                        <li>Long-press the image above and select "Save Image"</li>
                        <li>Copy this link: <input type="text" value="${url}" readonly style="width: 100%; padding: 4px; margin-top: 4px; font-size: 12px;" onclick="this.select()"></li>
                        <li>Share both via your preferred app</li>
                    </ol>
                `;
                
                // Remove existing instructions if any
                const existing = modal.querySelector('.manual-share-instructions');
                if (existing) existing.remove();
                
                modalBody.appendChild(instructions);
            }
            showNotification('Please follow the manual share steps below.', 'info');
        }

        function copyShareLink() {
            const shareLink = document.getElementById('shareLink');
            if (shareLink) {
                shareLink.select();
                document.execCommand('copy');
                showNotification('Link copied to clipboard!', 'success');
            }
        }

        function closeShareModal() {
            const modal = document.getElementById('shareModal');
            if (modal) modal.style.display = 'none';
            snapshotCanvas = null;
            snapshotBlob = null;
        }

        // ========================================
        // SHARED LINK ACCESS FUNCTIONS
        // ========================================

        async function joinGroupFromSharedLink(fetchedGroup, groupId) {
            // Add user to local group data first
            // Check if user is already a member BEFORE attempting to join
            const members = fetchedGroup.members || [];
            const userId = window.currentUser.id;
            const userName = window.currentUser.name;
            
            // Check if user is already a member (by ID or name)
            const userAlreadyMember = members.includes(userId) || 
                                     members.includes(userName) ||
                                     members.some(m => m && String(m).toLowerCase() === String(userId).toLowerCase()) ||
                                     members.some(m => m && String(m).toLowerCase() === String(userName).toLowerCase());
            
            // Join user to group in database (only if not already a member)
            let wasNewlyJoined = false;
            if (!userAlreadyMember && typeof window.joinUserToGroup === 'function') {
                const result = await window.joinUserToGroup(groupId, window.currentUser.id);
                if (!result || (typeof result === 'object' && !result.joined)) {
                    console.warn('Failed to join group in database, but continuing with local access');
                } else {
                    wasNewlyJoined = typeof result === 'object' ? result.wasNewMember : false;
                    console.log(wasNewlyJoined ? 'User successfully added to group in database' : 'User is already a member of this group');
                    // After joining, sync the entire group to ensure consistency
                    if (typeof window.syncGroupToDatabase === 'function') {
                        try {
                            await window.syncGroupToDatabase(fetchedGroup);
                            console.log('Group synced to database after user joined');
                        } catch (syncError) {
                            console.warn('Failed to sync group after join:', syncError);
                        }
                    }
                }
            } else if (userAlreadyMember) {
                console.log('User is already a member, skipping join');
            }

            // CRITICAL: Save group locally with proper structure
            const localGroups = loadFromLocalStorage();
            const existingIndex = localGroups.findIndex(g => g.id === groupId);
            if (existingIndex >= 0) {
                localGroups[existingIndex] = fetchedGroup;
            } else {
                localGroups.push(fetchedGroup);
            }
            saveGroupsToLocalStorage(localGroups);

            // Set as current group
            currentGroup = fetchedGroup;
            window.currentGroup = fetchedGroup;
            await updateGroupDisplay();

            // Start real-time sync for this group
            if (typeof window.startRealtimeSync === 'function') {
                setTimeout(() => {
                    window.startRealtimeSync();
                    console.log('Real-time sync started after joining group');
                }, 1000);
            }

            // Only show notification if user was newly joined
            if (wasNewlyJoined) {
                showNotification(`Successfully joined "${fetchedGroup.name}"!`, 'success');
            }
        }


        // FIXED: Edit Group function with proper error handling
        function handleEditGroup() {
            // Check if user is logged in
            if (!window.currentUser) {
                showNotification('Please log in to edit group', 'error');
                window.location.href = 'index.html';
                return;
            }
            
            console.log('Edit button clicked');
            console.log('Current group:', window.currentGroup || currentGroup);

            try {
                editGroup();
            } catch (error) {
                console.error('Error in editGroup:', error);
                showNotification('Failed to open edit dialog', 'error');
            }
        }

        function editGroup() {
            const group = window.currentGroup || currentGroup;

            if (!group) {
                console.error('No current group found');
                showNotification('Group data not available', 'error');
                return;
            }

            // Populate group name
            const nameInput = document.getElementById('editGroupName');
            if (nameInput) {
                nameInput.value = group.name;
            }

            // Setup members
            setupEditGroupMembers();

            // Show modal
            const modal = document.getElementById('editGroupModal');
            if (modal) {
                modal.style.display = 'block';
            }
        }

        function setupEditGroupMembers() {
            const group = window.currentGroup || currentGroup;

            if (!group) {
                return;
            }

            const grid = document.getElementById('editGroupMembersGrid');
            if (!grid) {
                return;
            }

            // Clear dynamic members container
            const dynamicContainer = document.getElementById('editGroupDynamicMembers');
            if (dynamicContainer) {
                dynamicContainer.innerHTML = '';
            }

            // Show only participants (manually added names), not registered members
            // Filter out IDs by checking if they match any registered member IDs
            const participants = Array.isArray(group.participants) ? group.participants : [];
            const memberIds = Array.isArray(group.members) ? group.members : [];
            
            // Helper to convert ID to name
            const getIdToName = (id) => {
                // Check if it's the current user
                if (window.currentUser && window.currentUser.id === id) {
                    return window.currentUser.name;
                }
                
                // Try to get from localStorage
                try {
                    const previousUsers = JSON.parse(localStorage.getItem('spliteasy_previous_users') || '[]');
                    const user = previousUsers.find(u => u.id === id);
                    if (user) return user.name;
                } catch (e) {
                    // Ignore
                }
                
                return null;
            };
            
            const participantNames = participants.map(p => {
                // First, try to convert IDs to names
                if (typeof p !== 'string') return null;
                
                // Check if this is a registered member ID (in members array)
                if (memberIds.includes(p)) {
                    return null; // This is a registered member ID, filter it out
                }
                
                // Check if p looks like an ID (pattern: letters followed by numbers, like "kaladeep0226")
                if (/^[a-zA-Z]+\d+$/.test(p)) {
                    const name = getIdToName(p);
                    if (name) {
                        // If we found a name, this is actually a registered member ID - filter it out
                        return null;
                    }
                    // If we can't convert it but it looks like an ID, filter it out anyway
                    return null;
                }
                
                // Filter out UUIDs and IDs with "user" pattern
                if (p.includes('user') || p.length > 30 || /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(p)) {
                    return null; // This looks like an ID
                }
                
                return p; // This looks like a participant name
            }).filter(p => p !== null); // Remove nulls (filtered out IDs)
            
            if (participantNames.length === 0) {
                grid.innerHTML = '<p style="color: var(--text-secondary); padding: 1rem;">No participants yet. Add participants below.</p>';
                return;
            }
            
            grid.innerHTML = participantNames.map(person => `
                <div class="selectable-box selected" data-member="${person}">
                    ${person}
                </div>
            `).join('');
        }

        function selectAllGroupMembers() {
            document.querySelectorAll('#editGroupMembersGrid .selectable-box').forEach(box => {
                box.classList.add('selected');
            });
        }

        function clearAllGroupMembers() {
            document.querySelectorAll('#editGroupMembersGrid .selectable-box').forEach(box => {
                box.classList.remove('selected');
            });
        }

        function addNewGroupMember() {
            const input = document.getElementById('editGroupNewMemberInput');
            const memberName = input.value.trim();

            if (!memberName) return;

            const existingMembers = Array.from(document.querySelectorAll('#editGroupMembersGrid .selectable-box')).map(box => box.dataset.member);
            const dynamicMembers = Array.from(document.querySelectorAll('#editGroupDynamicMembers .dynamic-item-name')).map(el => el.textContent);

            if (existingMembers.includes(memberName) || dynamicMembers.includes(memberName)) {
                showNotification('Member already exists', 'error');
                return;
            }

            const dynamicContainer = document.getElementById('editGroupDynamicMembers');
            const itemId = `editgroupmember${dynamicMemberCounter++}`;
            const memberItem = document.createElement('div');
            memberItem.className = 'dynamic-item';
            memberItem.id = itemId;
            memberItem.innerHTML = `
                <div class="dynamic-item-content">
                    <span class="dynamic-item-name">${memberName}</span>
                </div>
                <div class="dynamic-item-actions">
                    <button class="icon-btn edit" onclick="editGroupMember('${itemId}')" title="Edit">‚úé</button>
                    <button class="icon-btn delete" onclick="removeGroupMember('${itemId}')" title="Remove">√ó</button>
                </div>
            `;

            dynamicContainer.appendChild(memberItem);
            input.value = '';
            showNotification('Member added successfully', 'success');
        }

        function editGroupMember(itemId) {
            const item = document.getElementById(itemId);
            const nameEl = item.querySelector('.dynamic-item-name');
            const currentName = nameEl.textContent;
            const newName = prompt('Edit member name:', currentName);

            if (newName && newName.trim() && newName.trim() !== currentName) {
                nameEl.textContent = newName.trim();
                showNotification('Member updated', 'success');
            }
        }

        function removeGroupMember(itemId) {
            if (confirm('Remove this member?')) {
                document.getElementById(itemId).remove();
                showNotification('Member removed', 'success');
            }
        }

        // FIXED: Save group changes with database synchronization
        async function saveGroupChanges() {
            const groupName = document.getElementById('editGroupName')?.value.trim();
            const selectedBoxes = document.querySelectorAll('#editGroupMembersGrid .selectable-box.selected');
            const selectedMembers = Array.from(selectedBoxes).map(box => box.dataset.member);

            const dynamicMembers = Array.from(document.querySelectorAll('#editGroupDynamicMembers .dynamic-item-name')).map(el => el.textContent);

            const allPeople = [...selectedMembers, ...dynamicMembers];

            if (!groupName || allPeople.length < 2) {
                showNotification('Please provide group name and at least two members', 'error');
                return;
            }

            try {
                const group = window.currentGroup || currentGroup;

                // Keep existing registered member IDs (users who joined via shared link)
                // Since edit modal only shows participants, all entered names are participants
                const existingMemberIds = Array.isArray(group.members) ? group.members : [];
                
                // All entered names are participants (remove duplicates)
                const participantNames = [...new Set(allPeople)];

                // Update group data
                group.name = groupName;
                group.members = existingMemberIds;  // Keep registered user IDs unchanged
                group.participants = participantNames;  // Update participant names only

                // Update both references
                currentGroup = group;
                window.currentGroup = group;

                // REQUIRED: Save to Supabase first
                if (!window.supabaseClient) {
                    throw new Error('Supabase client not available');
                }

                if (typeof window.syncGroupToDatabase !== 'function') {
                    throw new Error('syncGroupToDatabase function not available');
                }

                showNotification('Updating group in cloud...', 'info');
                await window.syncGroupToDatabase(group);
                
                // CRITICAL: Save to storage cache
                updateGroupInStorage();

                // Update UI
                await updateGroupDisplay();

                closeEditGroupModal();
                showNotification('Group updated successfully!');

            } catch (error) {
                console.error('Failed to save group changes:', error);
                showNotification('Failed to update group', 'error');
            }
        }

        function closeEditGroupModal() {
            document.getElementById('editGroupModal').style.display = 'none';
            document.getElementById('editGroupDynamicMembers').innerHTML = '';
        }

        // FIXED: Delete group with database sync - only creator can delete
        async function deleteGroupConfirm() {
            if (!currentGroup) {
                showNotification('No group to delete', 'error');
                return;
            }

            // Check if current user is the creator (by ID)
            const creatorId = currentGroup.createdBy || currentGroup.created_by;
            const isCreator = window.currentUser && window.currentUser.id === creatorId;
            
            // If user is NOT the creator, allow them to leave the group
            if (!isCreator) {
                if (!confirm(`Are you sure you want to leave the group "${currentGroup.name}"? You will no longer see this group or its expenses.`)) {
                    return;
                }

                // Stop auto-refresh during deletion
                stopAutoRefresh();

                try {
                    // Remove user from group
                    if (typeof window.removeUserFromGroup === 'function') {
                        await window.removeUserFromGroup(currentGroupId, window.currentUser.id);
                        console.log('User removed from group');
                    } else {
                        throw new Error('Remove user function not available');
                    }

                    // Remove from local storage
                    const groups = loadFromLocalStorage().filter(g => {
                        return (g.id !== currentGroupId) && (g.supabaseId !== currentGroupId);
                    });
                    saveGroupsToLocalStorage(groups);
                    console.log('Group removed from localStorage. Remaining groups:', groups.length);

                    showNotification('You have left the group', 'success');
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1500);
                } catch (error) {
                    console.error('Failed to leave group:', error);
                    console.error('Error details:', error.message, error.stack);
                    
                    // Still remove from local storage even if database update fails
                    const groups = loadFromLocalStorage().filter(g => {
                        return (g.id !== currentGroupId) && (g.supabaseId !== currentGroupId);
                    });
                    saveGroupsToLocalStorage(groups);
                    
                    showNotification('Removed from your view. Group may still show if you refresh.', 'warning');
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1500);
                }
                return;
            }

            // Check if group has other members
            const members = currentGroup.members || [];
            const participants = currentGroup.participants || [];
            const allPeopleCount = members.length + participants.length;
            
            // If only creator is a member (no other members), delete immediately
            if (members.length === 1 && members[0] === window.currentUser.id && participants.length === 0) {
                if (!confirm(`Are you sure you want to delete the group "${currentGroup.name}"? All expenses will be lost forever!`)) return;
                
                // Stop auto-refresh during deletion
                stopAutoRefresh();
                
                try {
                    // Delete immediately (force delete)
                    if (typeof window.deleteGroupFromDatabase === 'function') {
                        await window.deleteGroupFromDatabase(currentGroupId, true); // Force delete
                        console.log('Group and all expenses deleted from database');
                    }

                    // Delete from local storage - check both id and supabaseId
                    const groups = loadFromLocalStorage().filter(g => {
                        // Keep groups that don't match currentGroupId by either id or supabaseId
                        return (g.id !== currentGroupId) && (g.supabaseId !== currentGroupId);
                    });
                    saveGroupsToLocalStorage(groups);
                    console.log('Group removed from localStorage. Remaining groups:', groups.length);

                    showNotification('Group and all expenses deleted successfully!', 'success');
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1500);
                } catch (error) {
                    console.error('Failed to delete group:', error);
                    showNotification('Failed to delete group from cloud. Deleted locally only.', 'warning');

                    // Delete from local storage - check both id and supabaseId
                    const groups = loadFromLocalStorage().filter(g => {
                        // Keep groups that don't match currentGroupId by either id or supabaseId
                        return (g.id !== currentGroupId) && (g.supabaseId !== currentGroupId);
                    });
                    saveGroupsToLocalStorage(groups);
                    console.log('Group removed from localStorage (fallback). Remaining groups:', groups.length);

                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1500);
                }
                return;
            }

            // Group has other members - initiate collaborative deletion
            const memberCount = members.length;
            if (!confirm(`This group has ${memberCount} member(s). Other members will be notified and must confirm deletion.\n\nDo you want to initiate group deletion?`)) return;

            // Stop auto-refresh during deletion
            stopAutoRefresh();

            try {
                // Mark group for collaborative deletion
                if (typeof window.deleteGroupFromDatabase === 'function') {
                    await window.deleteGroupFromDatabase(currentGroupId, false); // Collaborative deletion
                    console.log('Group marked for collaborative deletion');
                    
                    showNotification('Group deletion initiated. Other members will be notified to confirm.', 'info');
                    // Reload group to show pending deletion status
                    await loadGroupData(currentGroupId);
                } else {
                    throw new Error('Delete function not available');
                }
            } catch (error) {
                console.error('Failed to initiate group deletion:', error);
                console.error('Error details:', error.message, error.stack);
                showNotification('Failed to initiate group deletion. Please try again.', 'error');
            }
        }

        function goBack() {
            // Check if details view is visible
            const detailsView = document.getElementById('detailsView');
            if (detailsView && detailsView.style.display !== 'none') {
                hideDetailsView();
            } else {
            window.location.href = 'index.html';
            }
        }

        // ========================================
        // UTILITY FUNCTIONS (Using shared utilities)
        // ========================================
        // All utility functions are now in shared-utils.js
        // formatCurrency, formatDate, generateId, showNotification
        // are available globally from shared-utils.js

        <!-- Add this script to your HTML files for better cache management -->

// Enhanced Service Worker Registration with Update Detection
if ('serviceWorker' in navigator) {
  console.log('Registering service worker...');

  // Detect base path for GitHub Pages subdirectory
  const basePath = window.location.pathname.split('/').slice(0, -1).join('/') || '';
  const swPath = basePath ? `${basePath}/sw.js` : '/sw.js';
  console.log('Service worker path:', swPath);

  navigator.serviceWorker.register(swPath)
    .then(registration => {
      console.log('Service worker registered:', registration);

      // Check for updates every 30 seconds
      setInterval(() => {
        registration.update();
      }, 30000);

      // Listen for updates
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        console.log('New service worker found');

        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            console.log('New content available, will update...');

            // Show update notification
            if (typeof showNotification === 'function') {
              showNotification('App updated! Refreshing...', 'info');
            }

            // Auto-refresh after 2 seconds
            setTimeout(() => {
              window.location.reload();
            }, 2000);
          }
        });
      });
    })
    .catch(error => {
      console.log('Service worker registration failed:', error);
    });

  // Listen for messages from service worker
  navigator.serviceWorker.addEventListener('message', event => {
    console.log('Message from service worker:', event.data);

    if (event.data.type === 'SW_UPDATED') {
      if (typeof showNotification === 'function') {
        showNotification(event.data.message, 'success');
      } else {
        console.log(event.data.message);
      }
    }
  });
}

// Helper function to manually clear cache
window.clearAppCache = function() {
  if ('serviceWorker' in navigator && 'caches' in window) {
    // Send message to service worker
    navigator.serviceWorker.controller?.postMessage({type: 'CLEAR_CACHE'});

    // Also clear caches directly
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => caches.delete(cacheName))
      );
    }).then(() => {
      console.log('All caches cleared manually');
      if (typeof showNotification === 'function') {
        showNotification('Cache cleared! App will refresh...', 'success');
      }
      setTimeout(() => window.location.reload(), 1000);
    });
  }
};

// Helper function to force update
window.forceAppUpdate = function() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready.then(registration => {
      registration.update().then(() => {
        console.log('Forced service worker update');
        setTimeout(() => window.location.reload(), 1000);
      });
    });
  }
};

console.log('Cache management helpers loaded');
console.log('Use window.clearAppCache() to clear cache manually');  
console.log('Use window.forceAppUpdate() to force update');

        // ========================================
        // EVENT LISTENERS
        // ========================================

        // Toggle selectable boxes
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('selectable-box')) {
                e.target.classList.toggle('selected');
                
                // Update custom amounts list if split type is custom
                const splitType = document.getElementById('expenseSplitType')?.value;
                if (splitType === 'custom' && e.target.closest('#expenseSplitGrid')) {
                    updateCustomAmountsList();
                }
                
                const editSplitType = document.getElementById('editExpenseSplitType')?.value;
                if (editSplitType === 'custom' && e.target.closest('#editExpenseSplitGrid')) {
                    updateEditCustomAmountsList();
                }
            }
        });

        // Modal close handlers
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('modal')) {
                e.target.style.display = 'none';
            }
        });

        // Enter key for adding members
        document.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && e.target.id === 'editGroupNewMemberInput') {
                addNewGroupMember();
            }
        });

        // Debug: Log when script is fully loaded
        console.log('Group detail script fully loaded');
    </script>

    <!-- External Scripts -->
    <!-- Load config.js synchronously before Supabase scripts -->
    <script src="js/config.js"></script>
    <script src="js/shared-supabase.js"></script>
    <script src="js/shared-sync.js"></script>
</body>
</html>