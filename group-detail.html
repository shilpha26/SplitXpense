<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Group Details - SplitEasy</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#28a745">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
</head>
<body>
    <!-- Header -->
    <header class="group-header">
        <div class="container">
            <div class="group-header-left">
                <button class="btn-back" id="backBtn" onclick="goBack()">←</button>
                <div class="group-info">
                    <h1 id="groupName">Loading...</h1>
                    <p id="groupMeta">Loading group details...</p>
                </div>
            </div>
            <div class="group-actions">
                <button class="btn-secondary" id="shareBtn" onclick="shareGroup()">Share</button>
                <button class="btn-success" id="editBtn" onclick="handleEditGroup()">Edit</button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container">
        <!-- Total Expenses Card -->
        <div class="total-expenses">
            <h2 id="totalExpensesAmount">₹0.00</h2>
            <p>Total Expenses</p>
        </div>

        <!-- Expenses Section -->
        <section class="expenses-section">
            <div class="section-header">
                <div class="section-header-actions">
                <button class="btn-success" onclick="showAddExpenseModal()">Add Expense</button>
                </div>
            </div>
            <div id="expensesList" class="expenses-list">
                <!-- Expenses will be loaded here -->
            </div>
            <div id="noExpenses" class="empty-state">
                <p>No Expenses Yet</p>
                <p>Add your first expense to start tracking group spending!</p>
                <button class="btn-success btn-large" onclick="showAddExpenseModal()">Add First Expense</button>
            </div>
        </section>

        <!-- Balances Section -->
        <section class="balances-section">
            <div class="balances-header">
                <h3>Settlements needed</h3>
            </div>
            <div id="balancesList" class="balances-list">
                <!-- Settlements will be calculated and shown here -->
            </div>
            <div class="show-details-container">
                <button class="btn-success" onclick="showDetailsView()">Show details</button>
            </div>
        </section>

    </main>

    <!-- Details View (Tabbed Interface) -->
    <div id="detailsView" class="details-view" style="display: none;">
        <div class="container">
            <!-- Tab Navigation -->
            <div class="tab-navigation">
                <button class="tab-btn active" id="balancesTab" onclick="switchTab('balances')">Lending / Borrowing</button>
                <button class="tab-btn" id="expensesTab" onclick="switchTab('expenses')">Expense</button>
            </div>

            <!-- Balances Tab Content -->
            <div id="balancesTabContent" class="tab-content active">
                <div id="detailsIndividualBalances" class="individual-balances">
                    <!-- Individual balances will be shown here -->
                </div>
                <div class="balance-legend">
                    <span class="legend-item"><span class="legend-color blue"></span> Amount to receive</span>
                    <span class="legend-item"><span class="legend-color red"></span> Amount to pay</span>
                </div>
            </div>

            <!-- Expenses Tab Content -->
            <div id="expensesTabContent" class="tab-content">
                <div class="section-header">
                    <h3>Expenses</h3>
                </div>
                <div id="detailsExpensesList" class="expenses-list">
                    <!-- Expenses will be loaded here -->
                </div>
                <div id="detailsNoExpenses" class="empty-state">
                    <p>No Expenses Yet</p>
                    <p>Add your first expense to start tracking group spending!</p>
                    <button class="btn-success btn-large" onclick="showAddExpenseModal()">Add First Expense</button>
                </div>
                <div class="total-expense-summary">
                    <span class="total-label">Total Group Expense</span>
                    <span class="total-amount" id="detailsTotalExpensesAmount">₹0.00</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Expense Modal -->
    <div id="addExpenseModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Add Expense</h3>
                <span class="close" onclick="closeAddExpenseModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="expenseDescription">Description</label>
                    <input type="text" id="expenseDescription" placeholder="e.g., Dinner, Gas, Groceries" required>
                </div>
                <div class="form-group">
                    <label for="expenseAmount">Amount (₹)</label>
                    <input type="number" id="expenseAmount" placeholder="0.00" step="0.01" required>
                </div>
                <div class="form-group">
                    <label for="expensePaidBy">Paid By</label>
                    <select id="expensePaidBy" required>
                        <option value="">Select who paid</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Split Between</label>
                    <div class="selection-container">
                        <div class="selection-header">
                            <span>Select Members</span>
                            <div class="selection-actions">
                                <button class="selection-action" onclick="selectAllExpenseMembers()">Select All</button>
                                <button class="selection-action" onclick="clearAllExpenseMembers()">Clear All</button>
                            </div>
                        </div>
                        <div class="selectable-grid" id="expenseSplitGrid">
                            <!-- Member checkboxes will be added here -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" onclick="closeAddExpenseModal()">Cancel</button>
                <button type="button" class="btn-success" onclick="addExpense()">Add Expense</button>
            </div>
        </div>
    </div>

    <!-- Edit Expense Modal -->
    <div id="editExpenseModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Expense</h3>
                <span class="close" onclick="closeEditExpenseModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="editExpenseDescription">Description</label>
                    <input type="text" id="editExpenseDescription" placeholder="e.g., Dinner, Gas, Groceries" required>
                </div>
                <div class="form-group">
                    <label for="editExpenseAmount">Amount (₹)</label>
                    <input type="number" id="editExpenseAmount" placeholder="0.00" step="0.01" required>
                </div>
                <div class="form-group">
                    <label for="editExpensePaidBy">Paid By</label>
                    <select id="editExpensePaidBy" required>
                        <option value="">Select who paid</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Split Between</label>
                    <div class="selection-container">
                        <div class="selection-header">
                            <span>Select Members</span>
                            <div class="selection-actions">
                                <button class="selection-action" onclick="selectAllEditExpenseMembers()">Select All</button>
                                <button class="selection-action" onclick="clearAllEditExpenseMembers()">Clear All</button>
                            </div>
                        </div>
                        <div class="selectable-grid" id="editExpenseSplitGrid">
                            <!-- Member checkboxes will be added here -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" onclick="closeEditExpenseModal()">Cancel</button>
                <button type="button" class="btn-success" onclick="saveExpenseChanges()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Share Group Modal -->
    <div id="shareModal" class="modal">
        <div class="modal-content modal-small">
            <div class="modal-header">
                <h3>Share Group</h3>
                <span class="close" onclick="closeShareModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="shareLink">Share Link</label>
                    <input type="text" id="shareLink" readonly>
                    <button type="button" class="btn-success" onclick="copyShareLink()">Copy</button>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" onclick="closeShareModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Group Modal -->
    <div id="editGroupModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Group</h3>
                <span class="close" onclick="closeEditGroupModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="editGroupName">Group Name</label>
                    <input type="text" id="editGroupName" required>
                </div>
                <div class="form-group">
                    <label>Members</label>
                    <div class="selection-container">
                        <div class="selection-header">
                            <span>Edit Members</span>
                            <div class="selection-actions">
                                <button class="selection-action" onclick="selectAllGroupMembers()">Select All</button>
                                <button class="selection-action" onclick="clearAllGroupMembers()">Clear All</button>
                            </div>
                        </div>
                        <div class="selectable-grid" id="editGroupMembersGrid">
                            <!-- Members will be loaded here -->
                        </div>
                        <div class="add-item-section">
                            <input type="text" class="add-item-input" id="editGroupNewMemberInput" placeholder="Add new member">
                            <button class="btn-add" onclick="addNewGroupMember()" title="Add member">+</button>
                        </div>
                        <div class="dynamic-items" id="editGroupDynamicMembers">
                            <!-- Dynamically added members will appear here -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer-with-delete">
                <div class="modal-footer-left">
                    <button type="button" class="btn-danger" onclick="deleteGroupConfirm()">Delete Group</button>
                </div>
                <div class="modal-footer-right">
                    <button type="button" class="btn-secondary" onclick="closeEditGroupModal()">Cancel</button>
                    <button type="button" class="btn-success" onclick="saveGroupChanges()">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div id="notification" class="notification" style="display: none;"></div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="js/shared-utils.js"></script>
    <script>
        // ========================================
        // GLOBAL VARIABLES
        // ========================================
        let currentGroup = null;
        let currentGroupId = null;
        let editingExpenseId = null;
        let dynamicMemberCounter = 0;

        // Store group globally so it's accessible everywhere
        window.currentGroup = null;

        // ========================================
        // DETAILS VIEW & TAB NAVIGATION
        // ========================================
        function showDetailsView() {
            const mainContent = document.querySelector('main.container');
            const detailsView = document.getElementById('detailsView');
            
            if (mainContent) mainContent.style.display = 'none';
            if (detailsView) {
                detailsView.style.display = 'block';
                // Switch to balances tab by default
                switchTab('balances');
                // Update details view with current data
                updateDetailsView();
            }
        }

        function hideDetailsView() {
            const mainContent = document.querySelector('main.container');
            const detailsView = document.getElementById('detailsView');
            
            if (detailsView) detailsView.style.display = 'none';
            if (mainContent) mainContent.style.display = 'block';
        }

        function switchTab(tabName) {
            // Update tab buttons
            document.getElementById('balancesTab').classList.toggle('active', tabName === 'balances');
            document.getElementById('expensesTab').classList.toggle('active', tabName === 'expenses');
            
            // Update tab content
            document.getElementById('balancesTabContent').classList.toggle('active', tabName === 'balances');
            document.getElementById('expensesTabContent').classList.toggle('active', tabName === 'expenses');
            
            // Update content when switching tabs
            if (tabName === 'balances') {
                updateBalancesTab();
            } else if (tabName === 'expenses') {
                updateExpensesTab();
            }
        }

        function updateDetailsView() {
            updateBalancesTab();
            updateExpensesTab();
        }

        function updateBalancesTab() {
            if (!currentGroup || !currentGroup.expenses || currentGroup.expenses.length === 0) {
                const detailsBalances = document.getElementById('detailsIndividualBalances');
                if (detailsBalances) {
                    detailsBalances.innerHTML = '<p class="no-balances">No balances to display</p>';
                }
                return;
            }

            // Calculate balances
            const balances = {};
            currentGroup.members.forEach(member => {
                balances[member] = 0;
            });

            currentGroup.expenses.forEach(expense => {
                const amount = parseFloat(expense.amount);
                const splitBetween = expense.splitBetween || currentGroup.members;
                const perPerson = amount / splitBetween.length;

                if (balances[expense.paidBy] !== undefined) {
                    balances[expense.paidBy] += amount;
                }

                splitBetween.forEach(member => {
                    if (balances[member] !== undefined) {
                        balances[member] -= perPerson;
                    }
                });
            });

            // Display in details view
            const detailsBalances = document.getElementById('detailsIndividualBalances');
            if (detailsBalances) {
                const balanceEntries = Object.entries(balances)
                    .map(([member, amount]) => ({ name: member, amount }))
                    .sort((a, b) => {
                        if (a.amount < 0 && b.amount < 0) return a.amount - b.amount;
                        if (a.amount > 0 && b.amount > 0) return b.amount - a.amount;
                        return a.amount < b.amount ? -1 : 1;
                    });

                if (balanceEntries.length > 0) {
                    detailsBalances.innerHTML = `
                        <div class="individual-balances-list">
                            ${balanceEntries.map(({ name, amount }) => `
                                <div class="balance-item-simple">
                                    <span class="balance-name">${name}</span>
                                    <span class="balance-amount-simple ${amount > 0 ? 'receive' : amount < 0 ? 'pay' : 'zero'}">
                                        ${amount < 0 ? '-' : ''}${formatCurrency(Math.abs(amount))}
                                    </span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
            }
        }

        function updateExpensesTab() {
            if (!currentGroup || !currentGroup.expenses) return;

            const detailsExpensesList = document.getElementById('detailsExpensesList');
            const detailsNoExpenses = document.getElementById('detailsNoExpenses');
            const detailsTotal = document.getElementById('detailsTotalExpensesAmount');

            if (currentGroup.expenses.length === 0) {
                if (detailsExpensesList) detailsExpensesList.style.display = 'none';
                if (detailsNoExpenses) detailsNoExpenses.style.display = 'block';
                if (detailsTotal) detailsTotal.textContent = formatCurrency(0);
                return;
            }

            // Calculate each person's share (split amount, not what they paid)
            const allPeople = getAllGroupPeopleSync(currentGroup);
            const shareByPerson = {};
            allPeople.forEach(person => {
                shareByPerson[person] = 0;
            });

            currentGroup.expenses.forEach(expense => {
                const amount = parseFloat(expense.amount || 0);
                const splitBetween = expense.splitBetween || currentGroup.members;
                const perPerson = amount / splitBetween.length;

                // Each person who is part of the split gets their share
                splitBetween.forEach(member => {
                    if (shareByPerson[member] !== undefined) {
                        shareByPerson[member] += perPerson;
                    }
                });
            });

            // Convert to array and sort by amount (highest first)
            const shareEntries = Object.entries(shareByPerson)
                .map(([name, amount]) => ({ name, amount }))
                .sort((a, b) => b.amount - a.amount);

            if (detailsExpensesList) {
                detailsExpensesList.style.display = 'block';
                detailsExpensesList.innerHTML = shareEntries.map(({ name, amount }) => `
                    <div class="expense-item-simple">
                        <div class="expense-item-content">
                            <span class="expense-name">${name}</span>
                            <span class="expense-amount-simple">${formatCurrency(amount)}</span>
                        </div>
                    </div>
                `).join('');
            }

            if (detailsNoExpenses) detailsNoExpenses.style.display = 'none';
            if (detailsTotal) detailsTotal.textContent = formatCurrency(currentGroup.totalExpenses || 0);
        }

        // ========================================
        // INITIALIZATION
        // ========================================
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('Group Detail Page Loading...');
            console.log('Current URL:', window.location.href);
            console.log('URL search:', window.location.search);

            // REQUIRED: Initialize Supabase - app won't work without it
            if (typeof window.initializeSupabase !== 'function') {
                showNotification('Supabase initialization failed. Please check your configuration.', 'error');
                document.body.innerHTML = '<div style="padding: 2rem; text-align: center;"><h1>Configuration Error</h1><p>Supabase is required but not configured. Please check js/config.js</p></div>';
                return;
            }

            const supabaseInitialized = window.initializeSupabase();
            if (!supabaseInitialized) {
                showNotification('Supabase initialization failed. Please check your connection and configuration.', 'error');
                document.body.innerHTML = '<div style="padding: 2rem; text-align: center;"><h1>Connection Error</h1><p>Cannot connect to Supabase. Please check your internet connection and js/config.js configuration.</p></div>';
                return;
            }

            // Wait a moment for Supabase to fully initialize
            await new Promise(resolve => setTimeout(resolve, 500));

            if (!window.supabaseClient) {
                showNotification('Supabase client not available. Please refresh the page.', 'error');
                return;
            }

            // CRITICAL: Initialize user session first
            const userData = localStorage.getItem('spliteasy_current_user');
            if (userData) {
                try {
                    window.currentUser = JSON.parse(userData);
                    console.log('User session restored for group detail:', window.currentUser.name);
                } catch (error) {
                    console.error('Failed to parse user data:', error);
                    // Don't redirect immediately - might be a shared link
                }
            } else {
                console.warn('No user session found - will redirect to signup if accessing shared link');
            }

            // Get group ID from URL with enhanced debugging
            console.log('Parsing URL parameters...');
            const urlParams = new URLSearchParams(window.location.search);
            console.log('URL Params object:', urlParams);
            console.log('All URL param entries:', [...urlParams.entries()]);

            const groupId = urlParams.get('id');
            console.log('Group ID from URL:', groupId);

            if (groupId) {
                console.log('Group ID found, proceeding with load...');
                window.currentGroupId = groupId;
                currentGroupId = groupId;

                // If accessing via shared link and no user, redirect to signup first
                // Check this BEFORE trying to load the group
                if (!window.currentUser) {
                    console.log('No user logged in, redirecting to signup/login...');
                    const returnUrl = encodeURIComponent(window.location.href);
                    showNotification('Please sign up or log in to access this group', 'info');
                    setTimeout(() => {
                        window.location.href = `index.html?returnTo=${returnUrl}`;
                    }, 500);
                    return;
                }

                loadGroupData(groupId);
            } else {
                console.error('No group ID provided in URL');
                console.log('Available URL params:', window.location.search);

                showNotification('No group ID provided', 'error');
                setTimeout(() => {
                    window.location.href = 'index.html';
                }, 2000);
            }

            // Initialize real-time sync for group detail page
            if (window.currentUser && typeof window.startRealtimeSync === 'function') {
                console.log('Scheduling real-time sync initialization...');
                setTimeout(() => {
                    window.startRealtimeSync();
                }, 2000); // Give time for group to load
            } else {
                console.log('Real-time sync not initialized - missing user or function');
            }
        });

        // ========================================
        // CORE FUNCTIONS - FIXED FOR EXPENSE PERSISTENCE
        // ========================================

        // Helper function to get user name from ID
        // Checks localStorage first, then tries to fetch from database
        async function getUserNameFromId(userId) {
            if (!userId) return userId;
            
            // Check if it's the current user
            if (window.currentUser && window.currentUser.id === userId) {
                return window.currentUser.name;
            }
            
            // Check localStorage for previous users
            try {
                const previousUsers = JSON.parse(localStorage.getItem('spliteasy_previous_users') || '[]');
                const user = previousUsers.find(u => u.id === userId);
                if (user) return user.name;
            } catch (e) {
                console.warn('Error reading previous users:', e);
            }
            
            // Try to fetch from database
            if (window.supabaseClient) {
                try {
                    const { data, error } = await window.supabaseClient
                        .from('users')
                        .select('name')
                        .eq('id', userId)
                        .single();
                    
                    if (!error && data) {
                        return data.name;
                    }
                } catch (e) {
                    console.warn('Error fetching user name from database:', e);
                }
            }
            
            // Fallback: return ID if name not found
            return userId;
        }

        // Helper function to get all people in a group (registered members + participants)
        // Converts member IDs to names for display
        async function getAllGroupPeople(group) {
            if (!group) return [];
            
            // Get registered user IDs (members) and convert to names
            const memberIds = Array.isArray(group.members) ? group.members : [];
            const memberNames = await Promise.all(
                memberIds.map(async (id) => {
                    // Check if it's already a name (for backward compatibility)
                    if (typeof id === 'string' && !id.includes('user') && id.length < 20) {
                        return id; // Likely already a name
                    }
                    return await getUserNameFromId(id);
                })
            );
            
            // Get non-registered participant names
            const participants = Array.isArray(group.participants) ? group.participants : [];
            
            // Combine and remove duplicates
            const allPeople = [...memberNames, ...participants];
            return [...new Set(allPeople)]; // Remove duplicates
        }

        // Synchronous version for immediate use (uses cached data only)
        function getAllGroupPeopleSync(group) {
            if (!group) return [];
            
            // Get registered user IDs (members)
            const memberIds = Array.isArray(group.members) ? group.members : [];
            const memberNames = memberIds.map(id => {
                // Check if it's the current user
                if (window.currentUser && window.currentUser.id === id) {
                    return window.currentUser.name;
                }
                
                // Check if it's already a name (for backward compatibility)
                if (typeof id === 'string' && !id.includes('user') && id.length < 20) {
                    return id; // Likely already a name
                }
                
                // Try to get from localStorage
                try {
                    const previousUsers = JSON.parse(localStorage.getItem('spliteasy_previous_users') || '[]');
                    const user = previousUsers.find(u => u.id === id);
                    if (user) return user.name;
                } catch (e) {
                    // Ignore errors
                }
                
                // Fallback: return ID
                return id;
            });
            
            // Get non-registered participant names
            const participants = Array.isArray(group.participants) ? group.participants : [];
            
            // Combine and remove duplicates
            const allPeople = [...memberNames, ...participants];
            return [...new Set(allPeople)];
        }

        // FIXED: Enhanced loadGroupData - Supabase first
        async function loadGroupData(groupId) {
            console.log('Loading group data for ID:', groupId);

            // Check if user is logged in (required for accessing groups)
            if (!window.currentUser) {
                console.log('No user logged in, redirecting to signup/login...');
                const returnUrl = encodeURIComponent(window.location.href);
                showNotification('Please sign up or log in to access this group', 'info');
                setTimeout(() => {
                    window.location.href = `index.html?returnTo=${returnUrl}`;
                }, 500);
                return;
            }

            // REQUIRED: Load from Supabase first
            if (!window.supabaseClient) {
                showNotification('Supabase not available. Please check your connection.', 'error');
                // Fallback to localStorage cache (only if user is logged in)
                const groups = loadFromLocalStorage();
                const foundGroup = groups.find(g => g.id === groupId);
            if (foundGroup) {
                    currentGroup = foundGroup;
                    window.currentGroup = foundGroup;
                    await updateGroupDisplay();
                    showNotification('Using cached data. Some features may be limited.', 'warning');
                    return;
                } else {
                    showNotification('Group not found. Please check your connection.', 'error');
                    setTimeout(() => window.location.href = 'index.html', 2000);
                return;
                }
            }

            try {
                // Check if this is a shared link (UUID format) FIRST
                const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                const isSharedLink = uuidRegex.test(groupId);
                
                console.log('Group ID format check:', { groupId, isSharedLink });
                
                // If it's a shared link, skip the normal fetch and go straight to direct fetch
                if (isSharedLink) {
                    console.log('Detected shared link (UUID format), fetching directly from database...');
                    try {
                        // Try to fetch the group directly from Supabase without membership check
                        const { data: directGroup, error: directError } = await window.supabaseClient
                            .from('groups')
                            .select('*')
                            .eq('id', groupId)
                            .maybeSingle();
                        
                        if (directError) {
                            console.error('Error fetching group directly:', directError);
                            throw new Error(`Database error: ${directError.message}`);
                        }
                        
                        if (directGroup) {
                            console.log('Group found via shared link:', directGroup);
                            
                            // Ensure schema is detected
                            if (typeof window.detectDatabaseSchema === 'function') {
                                await window.detectDatabaseSchema();
                            }
                            
                            // Get schema mappings - check multiple possible locations
                            let schemaMapping = null;
                            if (typeof window.SCHEMA_MAPPING !== 'undefined') {
                                schemaMapping = window.SCHEMA_MAPPING;
                            } else if (typeof window.splitEasySync !== 'undefined' && window.splitEasySync.SCHEMA_MAPPING) {
                                schemaMapping = window.splitEasySync.SCHEMA_MAPPING;
                            } else {
                                // Fallback: try to access from shared-sync.js scope
                                // If not available, use default snake_case column names
                                console.warn('SCHEMA_MAPPING not found, using default column names');
                            }
                            
                            const expenseSchema = schemaMapping?.expenses || {};
                            const groupSchema = schemaMapping?.groups || {};
                            
                            // Fetch expenses for this group
                            const groupIdColumn = expenseSchema.groupId || 'group_id';
                            const { data: expenses, error: expensesError } = await window.supabaseClient
                                .from('expenses')
                                .select('*')
                                .eq(groupIdColumn, groupId)
                                .order(expenseSchema.createdAt || 'created_at', { ascending: false });
                            
                            if (expensesError) {
                                console.warn('Error fetching expenses:', expensesError);
                            }
                            
                                // Handle members array (registered user IDs) - might be JSONB string
                            let members = directGroup[groupSchema.members] || directGroup.members || [];
                            if (typeof members === 'string') {
                                try {
                                    members = JSON.parse(members);
                                } catch (e) {
                                    console.warn('Failed to parse members JSON:', e);
                                    members = [];
                                }
                            }
                            if (!Array.isArray(members)) {
                                members = [];
                            }
                            
                            // Handle participants array (non-registered member names) - might be JSONB string
                            let participants = directGroup[groupSchema.participants] || directGroup.participants || [];
                            if (typeof participants === 'string') {
                                try {
                                    participants = JSON.parse(participants);
                                } catch (e) {
                                    console.warn('Failed to parse participants JSON:', e);
                                    participants = [];
                                }
                            }
                            if (!Array.isArray(participants)) {
                                participants = [];
                            }
                            
                            // Structure the group data properly
                            const structuredGroup = {
                                id: directGroup[groupSchema.id] || directGroup.id,
                                supabaseId: directGroup[groupSchema.id] || directGroup.id,
                                name: directGroup[groupSchema.name] || directGroup.name,
                                members: members,  // Registered user IDs only
                                participants: participants,  // Non-registered member names
                                expenses: (expenses || []).map(exp => ({
                                    id: exp[expenseSchema.id] || exp.id,
                                    name: exp[expenseSchema.description] || exp.description || exp.name,
                                    amount: parseFloat(exp[expenseSchema.amount] || exp.amount || 0),
                                    paidBy: exp[expenseSchema.paidBy] || exp.paid_by || exp.paidby,
                                    splitBetween: exp[expenseSchema.splitBetween] || exp.split_between || [],
                                    date: exp[expenseSchema.createdAt] || exp.created_at || exp.createdat,
                                    perPersonAmount: exp[expenseSchema.perPersonAmount] || exp.per_person_amount || 0,
                                    supabaseId: exp[expenseSchema.id] || exp.id
                                })),
                                totalExpenses: 0,
                                createdAt: directGroup[groupSchema.createdAt] || directGroup.created_at || directGroup.createdat,
                                createdBy: directGroup[groupSchema.createdBy] || directGroup.created_by || directGroup.createdby
                            };
                            
                            // Calculate total expenses
                            structuredGroup.totalExpenses = structuredGroup.expenses.reduce((sum, exp) => sum + parseFloat(exp.amount || 0), 0);
                            
                            // Join user to group
                            console.log('Joining user to group...');
                            try {
                                await joinGroupFromSharedLink(structuredGroup, groupId);
                            } catch (joinError) {
                                console.warn('Error joining group (continuing anyway):', joinError);
                                // Continue even if join fails - user can still view the group
                            }
                            
                            // Set as current group and display
                            currentGroup = structuredGroup;
                            window.currentGroup = structuredGroup;
                            
                            // Save to localStorage
                            const localGroups = loadFromLocalStorage();
                            const existingIndex = localGroups.findIndex(g => g.id === groupId || g.supabaseId === groupId);
                            if (existingIndex >= 0) {
                                localGroups[existingIndex] = structuredGroup;
                            } else {
                                localGroups.push(structuredGroup);
                            }
                            saveGroupsToLocalStorage(localGroups);
                            
                            await updateGroupDisplay();
                            showNotification('Joined group successfully!', 'success');
                            return; // IMPORTANT: Return here to prevent falling through to error handler
                        } else {
                            console.log('Group not found in database with ID:', groupId);
                            // Continue to normal fetch flow below
                        }
                    } catch (shareError) {
                        console.error('Error processing shared link group:', shareError);
                        console.error('Share error details:', {
                            message: shareError.message,
                            stack: shareError.stack
                        });
                        // Don't throw here, let it fall through to normal fetch
                    }
                }
                
                // Normal flow: try to fetch group (checks membership)
                if (typeof window.fetchGroupFromDatabase !== 'function') {
                    throw new Error('fetchGroupFromDatabase function not available');
                }

                console.log('Fetching group using normal method (checks membership)...');
                const fetchedGroup = await window.fetchGroupFromDatabase(groupId);

                if (!fetchedGroup) {
                    // Group not found - try localStorage cache as fallback
                    const groups = loadFromLocalStorage();
                    const cachedGroup = groups.find(g => g.id === groupId || g.supabaseId === groupId);
                    if (cachedGroup) {
                    currentGroup = cachedGroup;
                    window.currentGroup = cachedGroup;
                    await updateGroupDisplay();
                    showNotification('Using cached data. Please check your connection.', 'warning');
                        return;
                    }
                    
                    // If it's a shared link, show a more helpful message
                    if (isSharedLink) {
                        showNotification('Group not found. The link may be invalid or the group was deleted.', 'error');
                    } else {
                        showNotification('Group not found. Please check your connection.', 'error');
                    }
                    setTimeout(() => window.location.href = 'index.html', 2000);
                    return;
                }

                // Cache in localStorage
                const localGroups = loadFromLocalStorage();
                const existingIndex = localGroups.findIndex(g => g.id === groupId);
                if (existingIndex >= 0) {
                    localGroups[existingIndex] = fetchedGroup;
                } else {
                localGroups.push(fetchedGroup);
                }
                saveGroupsToLocalStorage(localGroups);

                // Set as current group
                currentGroup = fetchedGroup;
                window.currentGroup = fetchedGroup;
                await updateGroupDisplay();

                showNotification('Group loaded successfully', 'success');
                return;
            } catch (error) {
                console.error('Failed to load group from Supabase:', error);
                
                // Fallback to localStorage cache
                const groups = loadFromLocalStorage();
                const foundGroup = groups.find(g => g.id === groupId);
                if (foundGroup) {
                    currentGroup = foundGroup;
                    window.currentGroup = foundGroup;
                    await updateGroupDisplay();
                    showNotification('Using cached data. Some features may be limited.', 'warning');
                    return;
                }
                
                // If still not found, show error
                showNotification('Failed to load group. Please check your connection.', 'error');
                setTimeout(() => window.location.href = 'index.html', 2000);
                return;
            }

            // Group not found locally - try to fetch from database
            console.log('Group not found locally, checking database...');
            
            // If no user is logged in, redirect to signup/login
            if (!window.currentUser) {
                console.log('No user logged in, redirecting to signup/login...');
                const returnUrl = encodeURIComponent(window.location.href);
                window.location.href = `index.html?returnTo=${returnUrl}`;
                return;
            }
            
            try {
                // Check if Supabase is available
                if (!window.supabaseClient) {
                    console.warn('Supabase not available, trying to initialize...');
                    if (typeof window.initializeSupabase === 'function') {
                        window.initializeSupabase();
                        // Wait a bit for initialization
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }

                // Fetch group from database
                if (typeof window.fetchGroupFromDatabase !== 'function') {
                    throw new Error('Database functions not available. Please check your internet connection.');
                }

                if (!window.supabaseClient) {
                    throw new Error('Database connection not available. Please check your internet connection.');
                }

                const fetchedGroup = await window.fetchGroupFromDatabase(groupId);

                if (!fetchedGroup) {
                    showNotification('Group not found. The link may be invalid or the group was deleted.', 'error');
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 3000);
                    return;
                }

                // User is logged in, automatically join the group
                console.log('User logged in, automatically joining group:', fetchedGroup.name);
                await joinGroupFromSharedLink(fetchedGroup, groupId);

            } catch (error) {
                console.error('Failed to load group from share link:', error);
                const errorMessage = error.message || 'Unknown error';
                
                // More helpful error messages
                if (errorMessage.includes('connection') || errorMessage.includes('network') || errorMessage.includes('fetch')) {
                    showNotification('Connection error. Please check your internet connection and try again.', 'error');
                } else if (errorMessage.includes('not available')) {
                    showNotification('Database service unavailable. Please try again later.', 'error');
                } else {
                    showNotification('Failed to load group. Please check your connection and try again.', 'error');
                }
                
                // Don't redirect immediately - give user time to read error
                setTimeout(() => {
                    window.location.href = 'index.html';
                }, 4000);
            }
        }

        // FIXED: Enhanced localStorage functions
        function loadFromLocalStorage() {
            try {
                const data = localStorage.getItem('spliteasy_groups');
                const groups = data ? JSON.parse(data) : [];
                console.log('LoadFromLocalStorage: Found', groups.length, 'groups');
                return groups;
            } catch (error) {
                console.error('Error loading from localStorage:', error);
                return [];
            }
        }

        // Optimized save function with batching and cache invalidation
        // Create a debounced version that works even if debounce isn't loaded yet
        let saveGroupsToLocalStorageTimeout = null;
        let lastGroupsToSave = null;
        
        function saveGroupsToLocalStorage(groups) {
            // Store the groups to save
            lastGroupsToSave = groups;
            
            // Clear existing timeout if debounce isn't available
            if (saveGroupsToLocalStorageTimeout) {
                clearTimeout(saveGroupsToLocalStorageTimeout);
            }

            const saveFunction = () => {
                const groupsToSave = lastGroupsToSave;
                if (!groupsToSave) return;
                
                try {
                    console.log('Saving', groupsToSave.length, 'groups to localStorage');

                // Ensure each group has proper structure and calculated totals
                    groupsToSave.forEach((group) => {
                    // Ensure expenses array exists
                    if (!group.expenses) {
                        group.expenses = [];
                    }

                    // Calculate total expenses
                    if (group.expenses.length > 0) {
                        group.totalExpenses = group.expenses.reduce((sum, exp) => sum + parseFloat(exp.amount || 0), 0);

                        // Ensure each expense has proper structure
                        group.expenses.forEach(expense => {
                            if (expense.splitBetween && expense.splitBetween.length > 0) {
                                expense.perPersonAmount = parseFloat(expense.amount || 0) / expense.splitBetween.length;
                            }
                        });
                    } else {
                        group.totalExpenses = 0;
                    }
                });

                    // Use batchLocalStorageOperation if available, otherwise direct save
                    if (typeof batchLocalStorageOperation === 'function') {
                        batchLocalStorageOperation(() => {
                            localStorage.setItem('spliteasy_groups', JSON.stringify(groupsToSave));
                            if (typeof invalidateGroupsCache === 'function') {
                                invalidateGroupsCache();
                            }
                            console.log('Successfully saved groups to localStorage');
                        });
                    } else {
                        localStorage.setItem('spliteasy_groups', JSON.stringify(groupsToSave));
                        console.log('Successfully saved groups to localStorage');
                    }

            } catch (error) {
                    console.error('Failed to save to localStorage:', error);
                showNotification('Failed to save data locally', 'error');
                }
            };

            // Use debounce if available, otherwise use setTimeout
            if (typeof debounce === 'function') {
                if (!window._debouncedSaveGroupsToLocalStorage) {
                    window._debouncedSaveGroupsToLocalStorage = debounce(saveFunction, 300);
                }
                window._debouncedSaveGroupsToLocalStorage();
            } else {
                // Fallback: simple debounce with setTimeout
                saveGroupsToLocalStorageTimeout = setTimeout(saveFunction, 300);
            }
        }

        // FIXED: Critical updateGroupInStorage function
        function updateGroupInStorage() {
            console.log('Updating group in storage for group ID:', currentGroupId);

            if (!currentGroup || !currentGroupId) {
                console.error('No currentGroup or currentGroupId to update');
                return;
            }

            try {
                // Load all groups from localStorage
                const allGroups = loadFromLocalStorage();
                console.log('Found', allGroups.length, 'total groups in storage');

                // Find the index of the current group
                const groupIndex = allGroups.findIndex(g => g.id === currentGroupId);

                if (groupIndex !== -1) {
                    console.log('📍 Found group at index', groupIndex, 'in localStorage');
                    console.log('Updating with', currentGroup.expenses?.length || 0, 'expenses');

                    // CRITICAL: Replace the entire group object with current data
                    allGroups[groupIndex] = { ...currentGroup };

                    // Update both global references
                    window.currentGroup = currentGroup;

                    // Save back to localStorage
                    saveGroupsToLocalStorage(allGroups);

                    console.log('Successfully updated group in storage');
                } else {
                    console.error('Group not found in localStorage for update');
                    // Group doesn't exist, add it
                    allGroups.push(currentGroup);
                    saveGroupsToLocalStorage(allGroups);
                    console.log('Added new group to storage');
                }
            } catch (error) {
                console.error('Failed to update group in storage:', error);
            }
        }

        // Helper function to update group display
        async function updateGroupDisplay() {
            if (!currentGroup) {
                console.error('No currentGroup to display');
                return;
            }

            console.log('🎨 Updating display for group:', currentGroup.name);
            console.log('Group has', currentGroup.expenses?.length || 0, 'expenses to display');

            safeUpdateElement('groupName', currentGroup.name);
            
            // Get creator name for display
            const creatorId = currentGroup.createdBy || currentGroup.created_by;
            const creatorName = creatorId === window.currentUser?.id 
                ? window.currentUser.name 
                : await getUserNameFromId(creatorId);
            
            // Check if group is pending deletion
            const pendingDeletion = currentGroup.pendingDeletion || currentGroup.pending_deletion;
            // Count only actual participant names (filter out IDs)
            const participants = Array.isArray(currentGroup.participants) ? currentGroup.participants : [];
            const memberIds = Array.isArray(currentGroup.members) ? currentGroup.members : [];
            const participantCount = participants.filter(p => {
                if (typeof p !== 'string') return false;
                // Filter out registered member IDs
                if (memberIds.includes(p)) {
                    return false; // This is a registered member ID, not a participant
                }
                // Filter out UUIDs and IDs with "user" pattern
                if (p.includes('user') || p.length > 30 || /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(p)) {
                    return false; // This looks like an ID
                }
                return true; // This looks like a participant name
            }).length;
            
            let metaText = `${participantCount} members • ${currentGroup.expenses?.length || 0} expenses • Created by ${creatorName} • ${formatDate(currentGroup.createdAt)}`;
            
            if (pendingDeletion) {
                metaText += ' • ⚠️ Pending Deletion';
                // Show deletion confirmation modal if user is a member (not creator)
                if (window.currentUser && creatorId !== window.currentUser.id) {
                    showDeletionConfirmationModal();
                }
            }
            
            safeUpdateElement('groupMeta', metaText);
            safeUpdateElement('totalExpensesAmount', formatCurrency(currentGroup.totalExpenses || 0));

            // Show/hide delete button based on creator
            const deleteBtn = document.getElementById('deleteBtn');
            if (deleteBtn) {
                if (window.currentUser && creatorId === window.currentUser.id && !pendingDeletion) {
                    deleteBtn.style.display = 'inline-block';
                } else {
                    deleteBtn.style.display = 'none';
                }
            }

            displayExpenses();
            calculateBalances();
        }

        // Show deletion confirmation modal for members
        function showDeletionConfirmationModal() {
            const modal = document.getElementById('deletionConfirmationModal');
            const message = document.getElementById('deletionMessage');
            const status = document.getElementById('deletionStatus');
            
            if (!currentGroup || !window.currentUser) return;
            
            const creatorId = currentGroup.createdBy || currentGroup.created_by;
            const creatorName = currentGroup.createdBy === window.currentUser?.id 
                ? window.currentUser.name 
                : getUserNameFromId(currentGroup.createdBy || currentGroup.created_by);
            
            // Get confirmation status
            const confirmedBy = currentGroup.deletionConfirmedBy || currentGroup.deletion_confirmed_by || [];
            const members = currentGroup.members || [];
            const allConfirmed = members.every(m => confirmedBy.includes(m));
            
            if (message) {
                message.textContent = `${creatorName} has requested to delete this group.`;
            }
            
            if (status) {
                if (allConfirmed) {
                    status.textContent = 'All members have confirmed. Group will be deleted.';
                    status.style.color = '#dc3545';
                } else {
                    const confirmedCount = confirmedBy.length;
                    status.textContent = `${confirmedCount} of ${members.length} members confirmed deletion.`;
                    status.style.color = '#ffc107';
                }
            }
            
            if (modal) modal.style.display = 'block';
        }

        function closeDeletionConfirmationModal() {
            const modal = document.getElementById('deletionConfirmationModal');
            if (modal) modal.style.display = 'none';
        }

        async function handleConfirmDeletion() {
            if (!currentGroup || !window.currentUser) return;
            
            try {
                if (typeof window.confirmGroupDeletion === 'function') {
                    await window.confirmGroupDeletion(currentGroup.id || currentGroup.supabaseId);
                    showNotification('You confirmed deletion. You will be removed from the group.', 'info');
                    closeDeletionConfirmationModal();
                    
                    // Reload group or redirect
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 2000);
                } else {
                    throw new Error('Confirm deletion function not available');
                }
            } catch (error) {
                console.error('Failed to confirm deletion:', error);
                showNotification('Failed to confirm deletion. Please try again.', 'error');
            }
        }

        async function handleRestoreGroup() {
            if (!currentGroup || !window.currentUser) return;
            
            try {
                if (typeof window.restoreGroup === 'function') {
                    await window.restoreGroup(currentGroup.id || currentGroup.supabaseId);
                    showNotification('Group restoration requested. The creator will be notified.', 'success');
                    closeDeletionConfirmationModal();
                    
                    // Reload group to update status
                    await loadGroupData(currentGroup.id || currentGroup.supabaseId);
                } else {
                    throw new Error('Restore group function not available');
                }
            } catch (error) {
                console.error('Failed to restore group:', error);
                showNotification('Failed to restore group. Please try again.', 'error');
            }
        }

        // safeUpdateElement is now in shared-utils.js

        // FIXED: Enhanced displayExpenses with detailed logging
        function displayExpenses() {
            console.log('🎨 DisplayExpenses called');
            console.log('Current group expenses:', currentGroup?.expenses?.length || 0);

            const expensesList = document.getElementById('expensesList');
            const noExpenses = document.getElementById('noExpenses');

            if (!currentGroup || !currentGroup.expenses || currentGroup.expenses.length === 0) {
                console.log('📭 No expenses to display');
                if (expensesList) expensesList.style.display = 'none';
                if (noExpenses) noExpenses.style.display = 'block';
                return;
            }

            console.log('Displaying', currentGroup.expenses.length, 'expenses');
            if (expensesList) expensesList.style.display = 'block';
            if (noExpenses) noExpenses.style.display = 'none';

            // Store all expenses for filtering
            if (allExpenses.length === 0 || allExpenses.length !== currentGroup.expenses.length) {
                allExpenses = [...currentGroup.expenses];
            }

            if (expensesList) {
                expensesList.innerHTML = currentGroup.expenses.map((expense, index) => {
                    console.log(`Expense ${index + 1}:`, expense.name, '-', formatCurrency(expense.amount));
                    return `
                        <div class="expense-item">
                            <div class="expense-item-header">
                                <div class="expense-actions">
                                    <button class="expense-action-btn edit" onclick="editExpense('${expense.id}')" title="Edit Expense">✎</button>
                                    <button class="expense-action-btn delete" onclick="deleteExpense('${expense.id}')" title="Delete Expense">×</button>
                                </div>
                            </div>
                            <div class="expense-content">
                                <div class="expense-info">
                                    <div class="expense-title-row">
                                    <h4>${expense.name}</h4>
                                        <div class="expense-amount">${formatCurrency(expense.amount)}</div>
                                </div>
                                    <div class="expense-meta-row">
                                        <span class="expense-meta">Paid by ${expense.paidBy} • Split between ${expense.splitBetween?.join(', ') || 'Unknown'}</span>
                                        <span class="expense-date">${formatDate(expense.date)}</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                console.log('Expenses HTML generated and inserted');
            }
        }

        // Store original expenses for filtering
        let allExpenses = [];

        function filterExpenses() {
            const searchInput = document.getElementById('expenseSearchInput');
            const searchTerm = (searchInput?.value || '').toLowerCase().trim();
            
            if (!currentGroup || !currentGroup.expenses) return;
            
            // Restore from allExpenses if needed
            if (allExpenses.length === 0) {
                allExpenses = [...currentGroup.expenses];
            }
            
            if (!searchTerm) {
                currentGroup.expenses = [...allExpenses];
            } else {
                currentGroup.expenses = allExpenses.filter(expense => 
                    expense.name.toLowerCase().includes(searchTerm) ||
                    expense.paidBy.toLowerCase().includes(searchTerm) ||
                    (expense.splitBetween && expense.splitBetween.some(member => member.toLowerCase().includes(searchTerm)))
                );
            }
            
            displayExpenses();
            calculateBalances();
        }

        // FIXED: Enhanced Settlement System
        function calculateBalances() {
            const balancesList = document.getElementById('balancesList');

            if (!balancesList || !currentGroup || !currentGroup.expenses || currentGroup.expenses.length === 0) {
                if (balancesList) {
                    balancesList.innerHTML = '<p class="no-settlements">No expenses to calculate settlements</p>';
                }
                return;
            }

            // Calculate individual balances
            // Combine registered members (IDs) and participants (names) for display
            const allPeople = getAllGroupPeopleSync(currentGroup);
            const balances = {};
            allPeople.forEach(person => {
                balances[person] = 0;
            });

            currentGroup.expenses.forEach(expense => {
                const amount = parseFloat(expense.amount);
                const splitBetween = expense.splitBetween || currentGroup.members;
                const perPerson = amount / splitBetween.length;

                // Person who paid gets credited
                if (balances[expense.paidBy] !== undefined) {
                    balances[expense.paidBy] += amount;
                }

                // Everyone who shared the expense gets debited
                splitBetween.forEach(member => {
                    if (balances[member] !== undefined) {
                        balances[member] -= perPerson;
                    }
                });
            });

            // Get creditors and debtors
            const creditors = [];
            const debtors = [];

            Object.entries(balances).forEach(([member, amount]) => {
                if (Math.abs(amount) > 0.01) {
                    if (amount > 0) {
                        creditors.push({ name: member, amount: amount });
                    } else {
                        debtors.push({ name: member, amount: Math.abs(amount) });
                    }
                }
            });

            creditors.sort((a, b) => b.amount - a.amount);
            debtors.sort((a, b) => b.amount - a.amount);

            // Calculate optimal settlements
            const settlements = [];
            let i = 0, j = 0;

            while (i < creditors.length && j < debtors.length) {
                const creditor = creditors[i];
                const debtor = debtors[j];
                const settlementAmount = Math.min(creditor.amount, debtor.amount);

                settlements.push({
                    from: debtor.name,
                    to: creditor.name,
                    amount: settlementAmount
                });

                creditor.amount -= settlementAmount;
                debtor.amount -= settlementAmount;

                if (creditor.amount < 0.01) i++;
                if (debtor.amount < 0.01) j++;
            }

            // Display settlements
            if (settlements.length === 0) {
                balancesList.innerHTML = `
                    <div class="settlement-complete">
                        <div class="settlement-icon">✓</div>
                        <h4>All Settled Up!</h4>
                        <p>No payments needed - everyone is even!</p>
                    </div>
                `;
            } else {
                const settlementHTML = settlements.map(settlement => `
                    <div class="settlement-item-modern">
                        <div class="settlement-info">
                            <span class="settlement-from-name">${settlement.from}</span>
                            <span class="settlement-arrow-modern">→</span>
                            <span class="settlement-to-name">${settlement.to}</span>
                            </div>
                        <div class="settlement-amount-modern">${formatCurrency(settlement.amount)}</div>
                    </div>
                `).join('');

                balancesList.innerHTML = `
                    <div class="settlements-list-modern">
                        ${settlementHTML}
                    </div>
                `;
            }
        }

        // ========================================
        // ADD EXPENSE FUNCTIONS - FIXED
        // ========================================
        function showAddExpenseModal() {
            const modal = document.getElementById('addExpenseModal');
            const paidBySelect = document.getElementById('expensePaidBy');
            const splitGrid = document.getElementById('expenseSplitGrid');

            if (modal) modal.style.display = 'block';

            // Populate paid by dropdown - combine members and participants (use names)
            if (paidBySelect && currentGroup) {
                const allPeople = getAllGroupPeopleSync(currentGroup);
                paidBySelect.innerHTML = '<option value="">Select who paid</option>' +
                    allPeople.map(person => 
                        `<option value="${person}">${person}</option>`
                    ).join('');
            }

            // Populate split between grid - combine members and participants (use names)
            if (splitGrid && currentGroup) {
                const allPeople = getAllGroupPeopleSync(currentGroup);
                splitGrid.innerHTML = allPeople.map(person => 
                    `<div class="selectable-box selected" data-member="${person}">
                        ${person}
                    </div>`
                ).join('');
            }
        }

        function closeAddExpenseModal() {
            const modal = document.getElementById('addExpenseModal');
            if (modal) modal.style.display = 'none';

            // Reset form
            ['expenseDescription', 'expenseAmount', 'expensePaidBy'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.value = '';
            });
        }

        function selectAllExpenseMembers() {
            document.querySelectorAll('#expenseSplitGrid .selectable-box').forEach(box => {
                box.classList.add('selected');
            });
        }

        function clearAllExpenseMembers() {
            document.querySelectorAll('#expenseSplitGrid .selectable-box').forEach(box => {
                box.classList.remove('selected');
            });
        }

        // FIXED: Critical addExpense function with proper persistence
        async function addExpense() {
            console.log('Adding new expense...');

            const description = document.getElementById('expenseDescription')?.value.trim();
            const amount = document.getElementById('expenseAmount')?.value;
            const paidBy = document.getElementById('expensePaidBy')?.value;
            const selectedBoxes = document.querySelectorAll('#expenseSplitGrid .selectable-box.selected');
            const splitBetween = Array.from(selectedBoxes).map(box => box.dataset.member);

            if (!description || !amount || !paidBy || splitBetween.length === 0) {
                showNotification('Please fill all fields', 'error');
                return;
            }

            // Check if user is logged in
            if (!window.currentUser) {
                showNotification('Please log in to add expenses', 'error');
                window.location.href = 'index.html';
                return;
            }

            const newExpense = {
                id: generateId(),
                name: description,
                amount: parseFloat(amount),
                paidBy: paidBy,
                splitBetween: splitBetween,
                date: new Date().toISOString(),
                perPersonAmount: parseFloat(amount) / splitBetween.length
            };

            console.log('📝 New expense created:', newExpense);

            // CRITICAL: Ensure expenses array exists
            if (!currentGroup.expenses) {
                currentGroup.expenses = [];
                console.log('Initialized expenses array');
            }

            // Add expense to current group
            currentGroup.expenses.push(newExpense);
            console.log('Added expense. Group now has', currentGroup.expenses.length, 'expenses');

            // Recalculate total
            currentGroup.totalExpenses = (currentGroup.totalExpenses || 0) + parseFloat(amount);
            console.log('New total expenses:', formatCurrency(currentGroup.totalExpenses));

            try {
                // Ensure user is set before syncing
                if (!window.currentUser) {
                    const userData = localStorage.getItem('spliteasy_current_user');
                    if (userData) {
                        window.currentUser = JSON.parse(userData);
                    } else {
                        // Create guest user if none exists
                        const guestUserId = 'guest_' + Date.now();
                        window.currentUser = {
                            id: guestUserId,
                            name: 'Guest',
                            createdAt: new Date().toISOString(),
                            isGuest: true
                        };
                        localStorage.setItem('spliteasy_current_user', JSON.stringify(window.currentUser));
                    }
                }

                // REQUIRED: Save to Supabase first
                if (!window.supabaseClient) {
                    throw new Error('Supabase client not available');
                }

                if (typeof window.syncExpenseToDatabase !== 'function') {
                    throw new Error('syncExpenseToDatabase function not available');
                }

                showNotification('Saving expense to cloud...', 'info');
                await window.syncExpenseToDatabase(newExpense, currentGroup.id);
                
                // CRITICAL: Save to storage cache
            updateGroupInStorage();

            // Update UI
            displayExpenses();
            calculateBalances();
            safeUpdateElement('totalExpensesAmount', formatCurrency(currentGroup.totalExpenses));

            // Close modal
            closeAddExpenseModal();

                showNotification('Expense added successfully!', 'success');
                
                // Reload group from Supabase to ensure sync
                await loadGroupData(currentGroup.id);
                } catch (error) {
                console.error('Failed to save expense:', error);
                showNotification('Failed to save expense. Please check your connection.', 'error');
                }
        }

        // ========================================
        // EDIT EXPENSE FUNCTIONS - FIXED
        // ========================================
        function editExpense(expenseId) {
            const expense = currentGroup.expenses.find(e => e.id === expenseId);
            if (!expense) return;

            editingExpenseId = expenseId;

            // Populate form
            document.getElementById('editExpenseDescription').value = expense.name;
            document.getElementById('editExpenseAmount').value = expense.amount;

            const paidBySelect = document.getElementById('editExpensePaidBy');
            const allPeople = getAllGroupPeopleSync(currentGroup);
            paidBySelect.innerHTML = '<option value="">Select who paid</option>' +
                allPeople.map(person => 
                    `<option value="${person}" ${person === expense.paidBy ? 'selected' : ''}>${person}</option>`
                ).join('');

            // Populate split between grid
            const splitGrid = document.getElementById('editExpenseSplitGrid');
            splitGrid.innerHTML = allPeople.map(person => 
                `<div class="selectable-box ${expense.splitBetween?.includes(person) ? 'selected' : ''}" data-member="${person}">
                    ${person}
                </div>`
            ).join('');

            document.getElementById('editExpenseModal').style.display = 'block';
        }

        function closeEditExpenseModal() {
            document.getElementById('editExpenseModal').style.display = 'none';
            editingExpenseId = null;
        }

        function selectAllEditExpenseMembers() {
            document.querySelectorAll('#editExpenseSplitGrid .selectable-box').forEach(box => {
                box.classList.add('selected');
            });
        }

        function clearAllEditExpenseMembers() {
            document.querySelectorAll('#editExpenseSplitGrid .selectable-box').forEach(box => {
                box.classList.remove('selected');
            });
        }

        // FIXED: Save expense changes with proper persistence
        async function saveExpenseChanges() {
            if (!editingExpenseId) return;

            const description = document.getElementById('editExpenseDescription')?.value.trim();
            const amount = document.getElementById('editExpenseAmount')?.value;
            const paidBy = document.getElementById('editExpensePaidBy')?.value;
            const selectedBoxes = document.querySelectorAll('#editExpenseSplitGrid .selectable-box.selected');
            const splitBetween = Array.from(selectedBoxes).map(box => box.dataset.member);

            if (!description || !amount || !paidBy || splitBetween.length === 0) {
                showNotification('Please fill all fields', 'error');
                return;
            }

            const expenseIndex = currentGroup.expenses.findIndex(e => e.id === editingExpenseId);
            if (expenseIndex !== -1) {
                const oldAmount = parseFloat(currentGroup.expenses[expenseIndex].amount);
                const newAmount = parseFloat(amount);

                // Preserve the expense ID and supabaseId to ensure update, not create
                const existingExpense = currentGroup.expenses[expenseIndex];
                currentGroup.expenses[expenseIndex] = {
                    ...existingExpense,
                    id: existingExpense.id, // Preserve original ID
                    supabaseId: existingExpense.supabaseId || existingExpense.id, // Preserve supabaseId or use id
                    name: description,
                    amount: newAmount,
                    paidBy: paidBy,
                    splitBetween: splitBetween,
                    perPersonAmount: newAmount / splitBetween.length
                };

                // Update total
                currentGroup.totalExpenses = (currentGroup.totalExpenses || 0) - oldAmount + newAmount;

                // REQUIRED: Save to Supabase first
                if (!window.supabaseClient) {
                    throw new Error('Supabase client not available');
                }

                if (typeof window.syncExpenseToDatabase !== 'function') {
                    throw new Error('syncExpenseToDatabase function not available');
                }

                showNotification('Updating expense in cloud...', 'info');
                await window.syncExpenseToDatabase(currentGroup.expenses[expenseIndex], currentGroup.id);
                
                // CRITICAL: Save to storage cache
                updateGroupInStorage();

                // Update UI
                displayExpenses();
                calculateBalances();
                safeUpdateElement('totalExpensesAmount', formatCurrency(currentGroup.totalExpenses));

                showNotification('Expense updated successfully!', 'success');
                
                // Reload group from Supabase to ensure sync
                await loadGroupData(currentGroup.id);

                closeEditExpenseModal();
                showNotification('Expense updated successfully!', 'success');
            }
        }

        // FIXED: Delete expense with proper persistence
        async function deleteExpense(expenseId) {
            const expense = currentGroup.expenses.find(e => e.id === expenseId);
            if (!expense) {
                console.error('Expense not found:', expenseId);
                return;
            }

            if (!confirm(`Are you sure you want to delete the expense "${expense.name}"?`)) return;

            try {
                // REQUIRED: Delete from Supabase first
                if (!window.supabaseClient) {
                    throw new Error('Supabase client not available');
                }

                if (typeof window.deleteExpenseFromDatabase !== 'function') {
                    throw new Error('deleteExpenseFromDatabase function not available');
                }

                showNotification('Deleting expense from cloud...', 'info');
                await window.deleteExpenseFromDatabase(expenseId);

                // Delete from local data
                const expenseIndex = currentGroup.expenses.findIndex(e => e.id === expenseId);
                if (expenseIndex !== -1) {
                    const deletedExpense = currentGroup.expenses[expenseIndex];
                    currentGroup.expenses.splice(expenseIndex, 1);
                    currentGroup.totalExpenses = Math.max(0, (currentGroup.totalExpenses || 0) - parseFloat(deletedExpense.amount));

                    // CRITICAL: Save changes to cache
                    updateGroupInStorage();

                    // Update UI
                    displayExpenses();
                    calculateBalances();
                    safeUpdateElement('totalExpensesAmount', formatCurrency(currentGroup.totalExpenses));

                    showNotification('Expense deleted successfully!', 'success');
                }
            } catch (error) {
                console.error('Delete expense failed:', error);
                showNotification(`Failed to delete expense: ${error.message}`, 'error');
            }
        }

        // ========================================
        // GROUP FUNCTIONS
        // ========================================
        function shareGroup() {
            const modal = document.getElementById('shareModal');
            const shareLink = document.getElementById('shareLink');
            const url = window.location.href;

            if (shareLink) shareLink.value = url;
            if (modal) modal.style.display = 'block';
        }

        function copyShareLink() {
            const shareLink = document.getElementById('shareLink');
            if (shareLink) {
                shareLink.select();
                document.execCommand('copy');
                showNotification('Link copied to clipboard!', 'success');
            }
        }

        function closeShareModal() {
            const modal = document.getElementById('shareModal');
            if (modal) modal.style.display = 'none';
        }

        // ========================================
        // SHARED LINK ACCESS FUNCTIONS
        // ========================================

        async function joinGroupFromSharedLink(fetchedGroup, groupId) {
            // Add user to local group data first
            // Check if members array contains IDs or names
            const members = fetchedGroup.members || [];
            const userId = window.currentUser.id;
            const userName = window.currentUser.name;
            
            // Check if user is already a member (by ID or name)
            const isAlreadyMember = members.includes(userId) || 
                                   members.includes(userName) ||
                                   members.some(m => m && String(m).toLowerCase() === String(userId).toLowerCase()) ||
                                   members.some(m => m && String(m).toLowerCase() === String(userName).toLowerCase());
            
            if (!isAlreadyMember) {
                // ALWAYS use user ID when joining (IDs are unique and reliable)
                // This ensures the user can be properly identified across the system
                fetchedGroup.members.push(userId);
                console.log('Added user ID to members:', userId);
                
                // Remove user's name if it exists (migrate from name to ID for consistency)
                const nameIndex = fetchedGroup.members.findIndex(m => 
                    String(m).toLowerCase() === String(userName).toLowerCase()
                );
                if (nameIndex >= 0 && fetchedGroup.members[nameIndex] !== userId) {
                    fetchedGroup.members.splice(nameIndex, 1);
                    console.log('Removed duplicate name entry, using ID instead');
                }
            }

            // Join user to group in database
            if (typeof window.joinUserToGroup === 'function') {
                const joined = await window.joinUserToGroup(groupId, window.currentUser.id);
                if (!joined) {
                    console.warn('Failed to join group in database, but continuing with local access');
                } else {
                    console.log('User successfully added to group in database');
                    // After joining, sync the entire group to ensure consistency
                    if (typeof window.syncGroupToDatabase === 'function') {
                        try {
                            await window.syncGroupToDatabase(fetchedGroup);
                            console.log('Group synced to database after user joined');
                        } catch (syncError) {
                            console.warn('Failed to sync group after join:', syncError);
                        }
                    }
                }
            }

            // CRITICAL: Save group locally with proper structure
            const localGroups = loadFromLocalStorage();
            const existingIndex = localGroups.findIndex(g => g.id === groupId);
            if (existingIndex >= 0) {
                localGroups[existingIndex] = fetchedGroup;
            } else {
                localGroups.push(fetchedGroup);
            }
            saveGroupsToLocalStorage(localGroups);

            // Set as current group
            currentGroup = fetchedGroup;
            window.currentGroup = fetchedGroup;
            await updateGroupDisplay();

            // Start real-time sync for this group
            if (typeof window.startRealtimeSync === 'function') {
                setTimeout(() => {
                    window.startRealtimeSync();
                    console.log('Real-time sync started after joining group');
                }, 1000);
            }

            showNotification(`Successfully joined "${fetchedGroup.name}"!`, 'success');
        }


        // FIXED: Edit Group function with proper error handling
        function handleEditGroup() {
            // Check if user is logged in
            if (!window.currentUser) {
                showNotification('Please log in to edit group', 'error');
                window.location.href = 'index.html';
                return;
            }
            
            console.log('Edit button clicked');
            console.log('Current group:', window.currentGroup || currentGroup);

            try {
                editGroup();
            } catch (error) {
                console.error('Error in editGroup:', error);
                showNotification('Failed to open edit dialog', 'error');
            }
        }

        function editGroup() {
            const group = window.currentGroup || currentGroup;

            if (!group) {
                console.error('No current group found');
                showNotification('Group data not available', 'error');
                return;
            }

            // Populate group name
            const nameInput = document.getElementById('editGroupName');
            if (nameInput) {
                nameInput.value = group.name;
            }

            // Setup members
            setupEditGroupMembers();

            // Show modal
            const modal = document.getElementById('editGroupModal');
            if (modal) {
                modal.style.display = 'block';
            }
        }

        function setupEditGroupMembers() {
            const group = window.currentGroup || currentGroup;

            if (!group) {
                return;
            }

            const grid = document.getElementById('editGroupMembersGrid');
            if (!grid) {
                return;
            }

            // Clear dynamic members container
            const dynamicContainer = document.getElementById('editGroupDynamicMembers');
            if (dynamicContainer) {
                dynamicContainer.innerHTML = '';
            }

            // Show only participants (manually added names), not registered members
            // Filter out IDs by checking if they match any registered member IDs
            const participants = Array.isArray(group.participants) ? group.participants : [];
            const memberIds = Array.isArray(group.members) ? group.members : [];
            
            const participantNames = participants.filter(p => {
                // Filter out IDs - check if this matches any registered member ID
                if (typeof p !== 'string') return false;
                
                // Check if this is a registered member ID
                if (memberIds.includes(p)) {
                    return false; // This is a registered member ID, not a participant name
                }
                
                // Also filter out UUIDs and IDs with "user" pattern
                if (p.includes('user') || p.length > 30 || /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(p)) {
                    return false; // This looks like an ID
                }
                
                return true; // This looks like a participant name
            });
            
            if (participantNames.length === 0) {
                grid.innerHTML = '<p style="color: var(--text-secondary); padding: 1rem;">No participants yet. Add participants below.</p>';
                return;
            }
            
            grid.innerHTML = participantNames.map(person => `
                <div class="selectable-box selected" data-member="${person}">
                    ${person}
                </div>
            `).join('');
        }

        function selectAllGroupMembers() {
            document.querySelectorAll('#editGroupMembersGrid .selectable-box').forEach(box => {
                box.classList.add('selected');
            });
        }

        function clearAllGroupMembers() {
            document.querySelectorAll('#editGroupMembersGrid .selectable-box').forEach(box => {
                box.classList.remove('selected');
            });
        }

        function addNewGroupMember() {
            const input = document.getElementById('editGroupNewMemberInput');
            const memberName = input.value.trim();

            if (!memberName) return;

            const existingMembers = Array.from(document.querySelectorAll('#editGroupMembersGrid .selectable-box')).map(box => box.dataset.member);
            const dynamicMembers = Array.from(document.querySelectorAll('#editGroupDynamicMembers .dynamic-item-name')).map(el => el.textContent);

            if (existingMembers.includes(memberName) || dynamicMembers.includes(memberName)) {
                showNotification('Member already exists', 'error');
                return;
            }

            const dynamicContainer = document.getElementById('editGroupDynamicMembers');
            const itemId = `editgroupmember${dynamicMemberCounter++}`;
            const memberItem = document.createElement('div');
            memberItem.className = 'dynamic-item';
            memberItem.id = itemId;
            memberItem.innerHTML = `
                <div class="dynamic-item-content">
                    <span class="dynamic-item-name">${memberName}</span>
                </div>
                <div class="dynamic-item-actions">
                    <button class="icon-btn edit" onclick="editGroupMember('${itemId}')" title="Edit">✎</button>
                    <button class="icon-btn delete" onclick="removeGroupMember('${itemId}')" title="Remove">×</button>
                </div>
            `;

            dynamicContainer.appendChild(memberItem);
            input.value = '';
            showNotification('Member added successfully', 'success');
        }

        function editGroupMember(itemId) {
            const item = document.getElementById(itemId);
            const nameEl = item.querySelector('.dynamic-item-name');
            const currentName = nameEl.textContent;
            const newName = prompt('Edit member name:', currentName);

            if (newName && newName.trim() && newName.trim() !== currentName) {
                nameEl.textContent = newName.trim();
                showNotification('Member updated', 'success');
            }
        }

        function removeGroupMember(itemId) {
            if (confirm('Remove this member?')) {
                document.getElementById(itemId).remove();
                showNotification('Member removed', 'success');
            }
        }

        // FIXED: Save group changes with database synchronization
        async function saveGroupChanges() {
            const groupName = document.getElementById('editGroupName')?.value.trim();
            const selectedBoxes = document.querySelectorAll('#editGroupMembersGrid .selectable-box.selected');
            const selectedMembers = Array.from(selectedBoxes).map(box => box.dataset.member);

            const dynamicMembers = Array.from(document.querySelectorAll('#editGroupDynamicMembers .dynamic-item-name')).map(el => el.textContent);

            const allPeople = [...selectedMembers, ...dynamicMembers];

            if (!groupName || allPeople.length < 2) {
                showNotification('Please provide group name and at least two members', 'error');
                return;
            }

            try {
                const group = window.currentGroup || currentGroup;

                // Keep existing registered member IDs (users who joined via shared link)
                // Since edit modal only shows participants, all entered names are participants
                const existingMemberIds = Array.isArray(group.members) ? group.members : [];
                
                // All entered names are participants (remove duplicates)
                const participantNames = [...new Set(allPeople)];

                // Update group data
                group.name = groupName;
                group.members = existingMemberIds;  // Keep registered user IDs unchanged
                group.participants = participantNames;  // Update participant names only

                // Update both references
                currentGroup = group;
                window.currentGroup = group;

                // REQUIRED: Save to Supabase first
                if (!window.supabaseClient) {
                    throw new Error('Supabase client not available');
                }

                if (typeof window.syncGroupToDatabase !== 'function') {
                    throw new Error('syncGroupToDatabase function not available');
                }

                showNotification('Updating group in cloud...', 'info');
                await window.syncGroupToDatabase(group);
                
                // CRITICAL: Save to storage cache
                updateGroupInStorage();

                // Update UI
                await updateGroupDisplay();

                closeEditGroupModal();
                showNotification('Group updated successfully!');

            } catch (error) {
                console.error('Failed to save group changes:', error);
                showNotification('Failed to update group', 'error');
            }
        }

        function closeEditGroupModal() {
            document.getElementById('editGroupModal').style.display = 'none';
            document.getElementById('editGroupDynamicMembers').innerHTML = '';
        }

        // FIXED: Delete group with database sync - only creator can delete
        async function deleteGroupConfirm() {
            if (!currentGroup) {
                showNotification('No group to delete', 'error');
                return;
            }

            // Check if current user is the creator (by ID)
            const creatorId = currentGroup.createdBy || currentGroup.created_by;
            if (!window.currentUser || window.currentUser.id !== creatorId) {
                const creatorName = await getUserNameFromId(creatorId);
                showNotification(`Only ${creatorName} (the creator) can delete this group`, 'error');
                return;
            }

            // Check if group has other members
            const members = currentGroup.members || [];
            const participants = currentGroup.participants || [];
            const allPeopleCount = members.length + participants.length;
            
            // If only creator is a member (no other members), delete immediately
            if (members.length === 1 && members[0] === window.currentUser.id && participants.length === 0) {
                if (!confirm(`Are you sure you want to delete the group "${currentGroup.name}"? All expenses will be lost forever!`)) return;
                
                try {
                    // Delete immediately (force delete)
                    if (typeof window.deleteGroupFromDatabase === 'function') {
                        await window.deleteGroupFromDatabase(currentGroupId, true); // Force delete
                        console.log('Group and all expenses deleted from database');
                    }

                    // Delete from local storage - check both id and supabaseId
                    const groups = loadFromLocalStorage().filter(g => {
                        // Keep groups that don't match currentGroupId by either id or supabaseId
                        return (g.id !== currentGroupId) && (g.supabaseId !== currentGroupId);
                    });
                    saveGroupsToLocalStorage(groups);
                    console.log('Group removed from localStorage. Remaining groups:', groups.length);

                    showNotification('Group and all expenses deleted successfully!', 'success');
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1500);
                } catch (error) {
                    console.error('Failed to delete group:', error);
                    showNotification('Failed to delete group from cloud. Deleted locally only.', 'warning');

                    // Delete from local storage - check both id and supabaseId
                    const groups = loadFromLocalStorage().filter(g => {
                        // Keep groups that don't match currentGroupId by either id or supabaseId
                        return (g.id !== currentGroupId) && (g.supabaseId !== currentGroupId);
                    });
                    saveGroupsToLocalStorage(groups);
                    console.log('Group removed from localStorage (fallback). Remaining groups:', groups.length);

                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1500);
                }
                return;
            }

            // Group has other members - initiate collaborative deletion
            const memberCount = members.length;
            if (!confirm(`This group has ${memberCount} member(s). Other members will be notified and must confirm deletion.\n\nDo you want to initiate group deletion?`)) return;

            try {
                // Mark group for collaborative deletion
                if (typeof window.deleteGroupFromDatabase === 'function') {
                    await window.deleteGroupFromDatabase(currentGroupId, false); // Collaborative deletion
                    console.log('Group marked for collaborative deletion');
                    
                    showNotification('Group deletion initiated. Other members will be notified to confirm.', 'info');
                    // Reload group to show pending deletion status
                    await loadGroupData(currentGroupId);
                } else {
                    throw new Error('Delete function not available');
                }
            } catch (error) {
                console.error('Failed to initiate group deletion:', error);
                showNotification('Failed to initiate group deletion. Please try again.', 'error');
            }
        }

        function goBack() {
            // Check if details view is visible
            const detailsView = document.getElementById('detailsView');
            if (detailsView && detailsView.style.display !== 'none') {
                hideDetailsView();
            } else {
            window.location.href = 'index.html';
            }
        }

        // ========================================
        // UTILITY FUNCTIONS (Using shared utilities)
        // ========================================
        // All utility functions are now in shared-utils.js
        // formatCurrency, formatDate, generateId, showNotification
        // are available globally from shared-utils.js

        <!-- Add this script to your HTML files for better cache management -->

// Enhanced Service Worker Registration with Update Detection
if ('serviceWorker' in navigator) {
  console.log('Registering service worker...');

  // Detect base path for GitHub Pages subdirectory
  const basePath = window.location.pathname.split('/').slice(0, -1).join('/') || '';
  const swPath = basePath ? `${basePath}/sw.js` : '/sw.js';
  console.log('Service worker path:', swPath);

  navigator.serviceWorker.register(swPath)
    .then(registration => {
      console.log('Service worker registered:', registration);

      // Check for updates every 30 seconds
      setInterval(() => {
        registration.update();
      }, 30000);

      // Listen for updates
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        console.log('New service worker found');

        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            console.log('New content available, will update...');

            // Show update notification
            if (typeof showNotification === 'function') {
              showNotification('App updated! Refreshing...', 'info');
            }

            // Auto-refresh after 2 seconds
            setTimeout(() => {
              window.location.reload();
            }, 2000);
          }
        });
      });
    })
    .catch(error => {
      console.log('Service worker registration failed:', error);
    });

  // Listen for messages from service worker
  navigator.serviceWorker.addEventListener('message', event => {
    console.log('Message from service worker:', event.data);

    if (event.data.type === 'SW_UPDATED') {
      if (typeof showNotification === 'function') {
        showNotification(event.data.message, 'success');
      } else {
        console.log(event.data.message);
      }
    }
  });
}

// Helper function to manually clear cache
window.clearAppCache = function() {
  if ('serviceWorker' in navigator && 'caches' in window) {
    // Send message to service worker
    navigator.serviceWorker.controller?.postMessage({type: 'CLEAR_CACHE'});

    // Also clear caches directly
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => caches.delete(cacheName))
      );
    }).then(() => {
      console.log('All caches cleared manually');
      if (typeof showNotification === 'function') {
        showNotification('Cache cleared! App will refresh...', 'success');
      }
      setTimeout(() => window.location.reload(), 1000);
    });
  }
};

// Helper function to force update
window.forceAppUpdate = function() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready.then(registration => {
      registration.update().then(() => {
        console.log('Forced service worker update');
        setTimeout(() => window.location.reload(), 1000);
      });
    });
  }
};

console.log('Cache management helpers loaded');
console.log('Use window.clearAppCache() to clear cache manually');  
console.log('Use window.forceAppUpdate() to force update');

        // ========================================
        // EVENT LISTENERS
        // ========================================

        // Toggle selectable boxes
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('selectable-box')) {
                e.target.classList.toggle('selected');
            }
        });

        // Modal close handlers
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('modal')) {
                e.target.style.display = 'none';
            }
        });

        // Enter key for adding members
        document.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && e.target.id === 'editGroupNewMemberInput') {
                addNewGroupMember();
            }
        });

        // Debug: Log when script is fully loaded
        console.log('Group detail script fully loaded');
    </script>

    <!-- External Scripts -->
    <!-- Load config.js synchronously before Supabase scripts -->
    <script src="js/config.js"></script>
    <script src="js/shared-supabase.js"></script>
    <script src="js/shared-sync.js"></script>
</body>
</html>