<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>SplitEasy - Share expenses, split the cost</title>
    <!-- Google Fonts - Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#22c55e">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="description" content="SplitEasy - A beautiful, intuitive expense splitting app for friends and groups">
</head>
<body>
    <!-- Loading Screen - Premium Design -->
    <div id="loadingScreen" class="loading-screen" style="display: flex; align-items: center; justify-content: center; min-height: 100vh; flex-direction: column; background: linear-gradient(135deg, #f8fafc 0%, #ecfdf5 100%);">
        <div style="text-align: center; padding: 2rem;">
            <div style="margin-bottom: 1.5rem;">
                <h1 style="font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; font-size: 2rem; font-weight: 800; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; letter-spacing: -0.03em; margin: 0;">SplitEasy</h1>
                <p style="color: #64748b; font-family: 'Inter', sans-serif; font-size: 0.875rem; margin-top: 0.5rem; font-weight: 500; letter-spacing: 0.025em;">Share expenses, split the cost</p>
            </div>
            <div class="spinner" style="border: 3px solid #e2e8f0; border-top: 3px solid #22c55e; border-radius: 50%; width: 36px; height: 36px; animation: spin 0.8s linear infinite; margin: 0 auto;"></div>
            <p id="loadingMessage" style="margin-top: 1.25rem; color: #94a3b8; font-family: 'Inter', sans-serif; font-size: 0.875rem; font-weight: 500;">Initializing...</p>
            <style>
                @keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
            </style>
        </div>
    </div>

    <!-- Main App Content -->
    <div id="mainAppContent" style="display: none;">
        <!-- Header -->
        <header>
            <div class="container">
                <div class="logo">
                    <h1>SplitEasy</h1>
                    <p>Share expenses, split the cost</p>
                </div>
                <div class="user-info">
                    <span id="currentUserName">Loading...</span>
                    <button class="btn-link" data-action="showEditUserNameModal" title="Edit Name" type="button" aria-label="Edit user name">✎</button>
                    <button class="btn-link" data-action="showChangeUserModal" type="button" aria-label="Change user">Change User</button>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="container">
            <!-- Groups Header -->
            <div class="groups-header">
                <div>
                    <h2>Your Groups</h2>
                    <p class="group-count" id="groupCount">0 groups</p>
                </div>
                <button class="btn-success" data-action="showCreateGroupModal" type="button" aria-label="Create new group">Create New Group</button>
            </div>

            <!-- Groups List -->
            <div id="groupsList" class="groups-list">
                <!-- Groups will be loaded here -->
            </div>

            <!-- Empty State - Delightful Design -->
            <div id="emptyState" class="empty-state">
                <p>No groups yet</p>
                <p>Create your first group to start splitting expenses with friends, roommates, or travel buddies.</p>
                <button class="btn-success" data-action="showCreateGroupModal" type="button" aria-label="Create your first group">Create Your First Group</button>
            </div>
        </main>
    </div>

    <!-- User Login Modal -->
    <div id="userLoginModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Welcome to SplitEasy</h3>
            </div>
            <div class="modal-body">
                <!-- Previous Users Section -->
                <div id="previousUsersSection" class="previous-users-section" style="display: none;">
                    <div class="section-header">
                        <h4>Previous Users</h4>
                        <button type="button" class="btn-link" data-action="showNewUserForm" aria-label="Add new user">Add New User</button>
                    </div>
                    <div id="previousUsersList" class="previous-users-list">
                        <!-- Previous users will be loaded here -->
                    </div>
                </div>

                <!-- New User Form -->
                <div id="newUserForm" class="new-user-form">
                    <div class="form-group">
                        <label for="userName">Your Name</label>
                        <input type="text" id="userName" placeholder="Enter your name" required>
                    </div>
                    <div class="form-group">
                        <label for="userIdInput">User ID</label>
                        <div class="input-with-status">
                            <input type="text" id="userIdInput" placeholder="Enter desired User ID" required>
                            <button type="button" class="btn-check" data-action="checkUserIdAvailability" disabled aria-label="Check user ID availability">Check</button>
                        </div>
                        <div class="form-help" id="userIdStatus">Enter a unique User ID</div>
                        <div class="form-help-text">User ID must be 3-20 characters, letters and numbers only</div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn-link" data-action="handleGenerateUserId" aria-label="Generate user ID">Generate User ID</button>
                        <button type="button" class="btn-success" data-action="createUser" id="continueBtn" disabled aria-label="Continue to app">Continue</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit User Name Modal -->
    <div id="editUserNameModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Your Name</h3>
                <span class="close" data-action="closeEditUserNameModal" role="button" tabindex="0" aria-label="Close edit name modal">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="editUserNameInput">Your Name</label>
                    <input type="text" id="editUserNameInput" placeholder="Enter your name" required>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" data-action="closeEditUserNameModal" aria-label="Cancel editing name">Cancel</button>
                <button type="button" class="btn-success" data-action="saveUserName" aria-label="Save name changes">Save</button>
            </div>
        </div>
    </div>

    <!-- Create Group Modal -->
    <div id="createGroupModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Create New Group</h3>
                <span class="close" data-action="closeCreateGroupModal" role="button" tabindex="0" aria-label="Close create group modal">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="groupName">Group Name</label>
                    <input type="text" id="groupName" placeholder="e.g., Weekend Trip, House Expenses" required>
                </div>
                <div class="form-group">
                    <label>Group Members</label>
                    <div class="selection-container">
                        <div class="selection-header">
                            <span>Select Members</span>
                            <div class="selection-actions">
                                <button class="selection-action" data-action="selectAllMembers" type="button" aria-label="Select all members">Select All</button>
                                <button class="selection-action" data-action="clearAllMembers" type="button" aria-label="Clear all member selections">Clear All</button>
                            </div>
                        </div>
                        <div class="selectable-grid" id="memberSelectionGrid">
                            <!-- Current user will be added here -->
                        </div>
                        <div class="add-item-section">
                            <input type="text" class="add-item-input" id="newMemberInput" placeholder="Add new member">
                            <button class="btn-add" data-action="addNewMember" type="button" title="Add member" aria-label="Add new member">+</button>
                        </div>
                        <div class="dynamic-items" id="dynamicMembers">
                            <!-- Dynamically added members will appear here -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" data-action="closeCreateGroupModal" aria-label="Cancel creating group">Cancel</button>
                <button type="button" class="btn-success" data-action="createGroup" aria-label="Create group">Create Group</button>
            </div>
        </div>
    </div>

    <!-- Edit Group Modal -->
    <div id="editGroupModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Group</h3>
                <span class="close" data-action="closeEditGroupModal" role="button" tabindex="0" aria-label="Close edit group modal">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="editGroupName">Group Name</label>
                    <input type="text" id="editGroupName" required>
                </div>
                <div class="form-group">
                    <label>Members</label>
                    <div class="selection-container">
                        <div class="selection-header">
                            <span>Edit Members</span>
                            <div class="selection-actions">
                                <button class="selection-action" data-action="selectAllEditMembers" type="button" aria-label="Select all members">Select All</button>
                                <button class="selection-action" data-action="clearAllEditMembers" type="button" aria-label="Clear all member selections">Clear All</button>
                            </div>
                        </div>
                        <div class="selectable-grid" id="editMemberSelectionGrid">
                            <!-- Members will be loaded here -->
                        </div>
                        <div class="add-item-section">
                            <input type="text" class="add-item-input" id="editNewMemberInput" placeholder="Add new member">
                            <button class="btn-add" data-action="addNewEditMember" type="button" title="Add member" aria-label="Add new member">+</button>
                        </div>
                        <div class="dynamic-items" id="editDynamicMembers">
                            <!-- Dynamically added members will appear here -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer-with-delete">
                <div class="modal-footer-left">
                    <button type="button" class="btn-danger" data-action="deleteGroupConfirm" aria-label="Delete group">Delete Group</button>
                </div>
                <div class="modal-footer-right">
                    <button type="button" class="btn-secondary" data-action="closeEditGroupModal" aria-label="Cancel editing group">Cancel</button>
                    <button type="button" class="btn-success" data-action="saveEditGroupChanges" aria-label="Save group changes">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div id="notification" class="notification" style="display: none;"></div>

    <!-- Scripts - Load in correct order for initialization -->
    <!-- 1. Supabase library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- 2. Configuration (must load before Supabase initialization) -->
    <script src="js/config.js"></script>
    <!-- 3. Core Utilities (Logger, Error Handler, DOM Utils, App State) -->
    <script src="js/logger.js"></script>
    <script src="js/error-handler.js"></script>
    <script src="js/dom-utils.js"></script>
    <script src="js/app-state.js"></script>
    <!-- 4. Shared Utilities -->
    <script src="js/shared-utils.js"></script>
    <!-- 5. Modal Utilities (replaces prompt/confirm) -->
    <script src="js/modal-utils.js"></script>
    <!-- 6. Supabase client initialization -->
    <script src="js/shared-supabase.js"></script>
    <!-- 7. Sync functionality -->
    <script src="js/shared-sync.js"></script>
    <!-- 8. Main application script (runs after all dependencies are loaded) -->
    <script>
        // ========================================
        // GLOBAL VARIABLES
        // ========================================
        window.groups = [];
        window.currentUser = null;
        let dynamicMemberCounter = 0;
        let editingGroupId = null;
        let editDynamicMemberCounter = 0;

        // Enhanced User Authentication Variables
        let userIdCheckTimeout = null;
        let isUserIdAvailable = false;

        // ========================================
        // INITIALIZATION
        // ========================================
        document.addEventListener('DOMContentLoaded', initializeApp);

        // Update loading message
        function updateLoadingMessage(message) {
            DOMUtils.setText('loadingMessage', message);
        }

        // Hide loading screen and show main content
        function showMainApp() {
            const loadingScreen = DOMUtils.get('loadingScreen');
            const mainApp = DOMUtils.get('mainAppContent');
            if (loadingScreen) loadingScreen.style.display = 'none';
            if (mainApp) mainApp.style.display = 'block';
        }

        async function initializeApp() {
            Logger?.info('Initializing SplitEasy...');
            updateLoadingMessage('Loading application...');

            // REQUIRED: Initialize Supabase - app won't work without it
            // Wait for Supabase library and initialization functions to be available
            let retries = 0;
            const maxRetries = 10;
            
            while (retries < maxRetries) {
                if (typeof window.supabase !== 'undefined' && 
                    typeof window.initializeSupabase === 'function') {
                    break;
                }
                updateLoadingMessage(`Loading Supabase... (${retries + 1}/${maxRetries})`);
                Logger?.debug(`Waiting for Supabase to load... (${retries + 1}/${maxRetries})`);
                await new Promise(resolve => setTimeout(resolve, 200));
                retries++;
            }

            if (typeof window.initializeSupabase !== 'function') {
                const errorMsg = 'Supabase initialization failed. Please check your configuration.';
                Logger?.error(errorMsg);
                updateLoadingMessage('Configuration error');
                if (typeof showNotification === 'function') {
                    showNotification(errorMsg, 'error');
                }
                // Create error screen safely
                const errorDiv = DOMUtils.create('div', {
                    style: 'padding: 2rem; text-align: center;'
                });
                const h1 = DOMUtils.create('h1', {}, 'Configuration Error');
                const p1 = DOMUtils.create('p', {}, 'Supabase is required but not configured. Please check js/config.js');
                const buttonContainer = DOMUtils.create('p', {
                    style: 'margin-top: 1rem;'
                });
                const retryBtn = DOMUtils.create('button', {
                    'data-action': 'reloadPage',
                    style: 'padding: 0.5rem 1rem; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;',
                    type: 'button'
                }, 'Retry');
                buttonContainer.appendChild(retryBtn);
                errorDiv.appendChild(h1);
                errorDiv.appendChild(p1);
                errorDiv.appendChild(buttonContainer);
                document.body.textContent = '';
                document.body.appendChild(errorDiv);
                // Make reload function available
                window.reloadPage = () => window.location.reload();
                return;
            }

            // Initialize Supabase with retry logic
            updateLoadingMessage('Connecting to database...');
            let supabaseInitialized = false;
            retries = 0;
            
            while (retries < 5 && !supabaseInitialized) {
                supabaseInitialized = window.initializeSupabase();
                if (!supabaseInitialized) {
                    updateLoadingMessage(`Connecting to database... (${retries + 1}/5)`);
                    Logger?.debug(`Supabase initialization attempt ${retries + 1}/5...`);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    retries++;
                }
            }

            if (!supabaseInitialized) {
                const errorMsg = 'Supabase initialization failed. Please check your connection and configuration.';
                Logger?.error(errorMsg);
                updateLoadingMessage('Connection failed');
                if (typeof showNotification === 'function') {
                    showNotification(errorMsg, 'error');
                }
                // Create error screen safely
                const errorDiv = DOMUtils.create('div', {
                    style: 'padding: 2rem; text-align: center;'
                });
                const h1 = DOMUtils.create('h1', {}, 'Connection Error');
                const p1 = DOMUtils.create('p', {}, 'Cannot connect to Supabase. Please check your internet connection and js/config.js configuration.');
                const buttonContainer = DOMUtils.create('p', {
                    style: 'margin-top: 1rem;'
                });
                const retryBtn = DOMUtils.create('button', {
                    'data-action': 'reloadPage',
                    style: 'padding: 0.5rem 1rem; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;',
                    type: 'button'
                }, 'Retry');
                buttonContainer.appendChild(retryBtn);
                errorDiv.appendChild(h1);
                errorDiv.appendChild(p1);
                errorDiv.appendChild(buttonContainer);
                document.body.textContent = '';
                document.body.appendChild(errorDiv);
                // Make reload function available
                window.reloadPage = () => window.location.reload();
                return;
            }

            // Wait for Supabase client to be available
            updateLoadingMessage('Initializing database connection...');
            retries = 0;
            while (retries < 10 && !window.supabaseClient) {
                updateLoadingMessage(`Initializing... (${retries + 1}/10)`);
                Logger?.debug(`Waiting for Supabase client... (${retries + 1}/10)`);
                await new Promise(resolve => setTimeout(resolve, 300));
                retries++;
            }

            if (!window.supabaseClient) {
                const errorMsg = 'Supabase client not available. Please refresh the page.';
                Logger?.error(errorMsg);
                updateLoadingMessage('Initialization failed');
                if (typeof showNotification === 'function') {
                    showNotification(errorMsg, 'error');
                }
                // Create error screen safely
                const errorDiv = DOMUtils.create('div', {
                    style: 'padding: 2rem; text-align: center;'
                });
                const h1 = DOMUtils.create('h1', {}, 'Connection Error');
                const p1 = DOMUtils.create('p', {}, 'Supabase client failed to initialize. Please refresh the page.');
                const buttonContainer = DOMUtils.create('p', {
                    style: 'margin-top: 1rem;'
                });
                const refreshBtn = DOMUtils.create('button', {
                    'data-action': 'reloadPage',
                    style: 'padding: 0.5rem 1rem; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;',
                    type: 'button'
                }, 'Refresh Page');
                buttonContainer.appendChild(refreshBtn);
                errorDiv.appendChild(h1);
                errorDiv.appendChild(p1);
                errorDiv.appendChild(buttonContainer);
                document.body.textContent = '';
                document.body.appendChild(errorDiv);
                // Make reload function available
                window.reloadPage = () => window.location.reload();
                return;
            }

            Logger?.info('Supabase initialized successfully');
            updateLoadingMessage('Loading your data...');

            // Check for return URL (from shared link)
            const urlParams = new URLSearchParams(window.location.search);
            const returnTo = urlParams.get('returnTo');
            if (returnTo) {
                // Store return URL for after signup
                sessionStorage.setItem('returnToAfterSignup', returnTo);
            }

            // Check for existing user
            updateLoadingMessage('Checking user session...');
            const userData = localStorage.getItem('spliteasy_current_user');
            const previousUsers = getPreviousUsers();

            if (userData) {
                window.currentUser = JSON.parse(userData);
                DOMUtils.setText('currentUserName', window.currentUser.name);
                await loadGroups();
                showMainContent();
                showMainApp(); // Hide loading screen
                
                // If there's a return URL, redirect after a moment
                if (returnTo) {
                    setTimeout(() => {
                        window.location.href = decodeURIComponent(returnTo);
                    }, 1000);
                }
            } else if (previousUsers.length > 0) {
                showMainApp(); // Hide loading screen
                showUserLoginModal(true); // Show with previous users
            } else {
                showMainApp(); // Hide loading screen
                showUserLoginModal(false); // Show new user form
            }
        }

        // ========================================
        // USER AUTHENTICATION FUNCTIONS
        // ========================================

        // FIXED: Enhanced User Login Modal - cleaner previous users view
        function showUserLoginModal(hasPreviousUsers = false) {
            const modal = DOMUtils.get('userLoginModal');
            const previousSection = DOMUtils.get('previousUsersSection');
            const newUserForm = DOMUtils.get('newUserForm');

            if (hasPreviousUsers) {
                loadPreviousUsers();
                previousSection.style.display = 'block';
                newUserForm.style.display = 'none';
            } else {
                previousSection.style.display = 'none';
                newUserForm.style.display = 'block';
                setupUserIdInput();
            }

            modal.style.display = 'block';
        }

        // Show change user modal (called from "Change User" button)
        function showChangeUserModal() {
            const previousUsers = getPreviousUsers();
            showUserLoginModal(previousUsers.length > 0);
        }

        // Show edit user name modal
        function showEditUserNameModal() {
            if (!window.currentUser) {
                showNotification('Please log in first', 'error');
                showChangeUserModal();
                return;
            }

            const modal = DOMUtils.get('editUserNameModal');
            const nameInput = DOMUtils.get('editUserNameInput');
            
            if (modal && nameInput) {
                nameInput.value = window.currentUser.name || '';
                modal.style.display = 'block';
                // Focus on input after modal is shown for accessibility
                setTimeout(() => {
                    nameInput.focus();
                    DOMUtils.focus('editUserNameInput');
                }, 100);
            }
        }

        // Close edit user name modal
        function closeEditUserNameModal() {
            const modal = DOMUtils.get('editUserNameModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Save user name changes
        async function saveUserName() {
            if (!window.currentUser) {
                showNotification('Please log in first', 'error');
                return;
            }

            const nameInput = DOMUtils.get('editUserNameInput');
            const newName = nameInput?.value.trim();

            if (!newName) {
                showNotification('Please enter a name', 'error');
                return;
            }

            if (newName === window.currentUser.name) {
                closeEditUserNameModal();
                return; // No change
            }

            try {
                // Update current user
                window.currentUser.name = newName;
                localStorage.setItem('spliteasy_current_user', JSON.stringify(window.currentUser));

                // Update in previous users list
                const previousUsers = getPreviousUsers();
                const userIndex = previousUsers.findIndex(u => u.id === window.currentUser.id);
                if (userIndex >= 0) {
                    previousUsers[userIndex].name = newName;
                    previousUsers[userIndex].lastUsed = Date.now();
                    localStorage.setItem('spliteasy_previous_users', JSON.stringify(previousUsers));
                } else {
                    // Add to previous users if not there
                    storePreviousUser(window.currentUser);
                }

                // Update in database if available
                if (window.supabaseClient && typeof window.syncUserToDatabase === 'function') {
                    try {
                        await window.syncUserToDatabase(window.currentUser);
                        Logger?.info('User name updated in database');
                    } catch (dbError) {
                        Logger?.warn('Failed to update user name in database:', dbError);
                        // Continue anyway - local update succeeded
                    }
                }

                // Update UI
                DOMUtils.setText('currentUserName', newName);
                closeEditUserNameModal();
                showNotification('Name updated successfully!', 'success');

                // Invalidate cache to refresh any cached user data
                if (typeof invalidateGroupsCache === 'function') {
                    invalidateGroupsCache();
                }

            } catch (error) {
                Logger?.error('Failed to update user name:', error);
                ErrorHandler?.handle(error, 'saveUserName', true);
            }
        }

        // Setup User ID input validation
        function setupUserIdInput() {
            const userIdInput = DOMUtils.get('userIdInput');
            const checkBtn = document.querySelector('.btn-check');
            const continueBtn = DOMUtils.get('continueBtn');
            const userNameInput = DOMUtils.get('userName');

            // User ID input validation
            userIdInput.addEventListener('input', function() {
                const userId = this.value.trim();

                // Reset status
                resetUserIdStatus();
                isUserIdAvailable = false;
                updateContinueButton();

                if (userId.length >= 3 && isValidUserId(userId)) {
                    checkBtn.disabled = false;

                    // Clear previous timeout
                    clearTimeout(userIdCheckTimeout);

                    // Auto-check after 1 second of typing
                    userIdCheckTimeout = setTimeout(checkUserIdAvailability, 1000);
                } else {
                    checkBtn.disabled = true;
                    if (userId.length > 0) {
                        setUserIdStatus('Invalid User ID format', 'error');
                    }
                }
            });

            // User name input validation
            userNameInput.addEventListener('input', function() {
                updateContinueButton();
            });
        }

        // Update continue button state
        function updateContinueButton() {
            const continueBtn = DOMUtils.get('continueBtn');
            const userNameInput = DOMUtils.get('userName');
            const userIdInput = DOMUtils.get('userIdInput');
            const userName = userNameInput?.value.trim() || '';
            const userId = userIdInput?.value.trim() || '';

            if (userName && userId && isUserIdAvailable) {
                continueBtn.disabled = false;
            } else {
                continueBtn.disabled = true;
            }
        }

        // Validate User ID format
        function isValidUserId(userId) {
            const regex = /^[a-zA-Z0-9]{3,20}$/;
            return regex.test(userId);
        }

        // Check User ID availability
        async function checkUserIdAvailability() {
            const userIdInput = DOMUtils.get('userIdInput');
            if (!userIdInput) return;
            const userId = userIdInput.value.trim();
            const checkBtn = document.querySelector('.btn-check');

            if (!userId || !isValidUserId(userId)) {
                setUserIdStatus('Invalid User ID format', 'error');
                return;
            }

            // Show checking status
            setUserIdStatus('Checking availability...', 'checking');
            checkBtn.disabled = true;
            checkBtn.textContent = '...';

            try {
                // Check against previous local users first
                const previousUsers = getPreviousUsers();
                const localExists = previousUsers.some(user => user.id.toLowerCase() === userId.toLowerCase());

                if (localExists) {
                    setUserIdStatus('User ID is unavailable', 'error');
                    isUserIdAvailable = false;
                    updateContinueButton();
                    return;
                }

                // Check against database if available
                if (typeof window.checkUserIdExists === 'function' && window.supabaseClient) {
                    const exists = await window.checkUserIdExists(userId);

                    if (exists) {
                        setUserIdStatus('User ID is unavailable', 'error');
                        isUserIdAvailable = false;
                    } else {
                        setUserIdStatus('User ID is available', 'success');
                        isUserIdAvailable = true;
                    }
                } else {
                    // Offline mode - assume available
                    setUserIdStatus('User ID is available (offline mode)', 'success');
                    isUserIdAvailable = true;
                }

                updateContinueButton();

            } catch (error) {
                Logger?.error('User ID check failed:', error);
                setUserIdStatus('Unable to verify availability (offline mode)', 'warning');
                isUserIdAvailable = true; // Allow in offline mode
                updateContinueButton();
            } finally {
                checkBtn.disabled = false;
                checkBtn.textContent = 'Check';
            }
        }

        // Set User ID status
        function setUserIdStatus(message, type) {
            const statusEl = DOMUtils.get('userIdStatus');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = `form-help ${type}`;
                // Add ARIA live region for screen readers
                statusEl.setAttribute('role', 'status');
                statusEl.setAttribute('aria-live', 'polite');
            }
        }

        // Reset User ID status
        function resetUserIdStatus() {
            setUserIdStatus('Enter a unique User ID', '');
        }

        // Enhanced Generate User ID
        function handleGenerateUserId() {
            const userNameInput = DOMUtils.get('userName');
            if (!userNameInput) return;
            const userName = userNameInput.value.trim();
            if (!userName) {
                showNotification('Please enter your name first', 'error');
                return;
            }

            let userId = generateUniqueUserId(userName);
            const userIdInput = DOMUtils.get('userIdInput');
            if (userIdInput) {
                userIdInput.value = userId;
            }

            // Trigger availability check
            checkUserIdAvailability();
        }

        // Generate unique User ID
        function generateUniqueUserId(name) {
            const previousUsers = getPreviousUsers();
            const baseId = generateUserIdFromName(name);
            let userId = baseId;
            let counter = 1;

            // Ensure uniqueness against local users
            while (previousUsers.some(user => user.id.toLowerCase() === userId.toLowerCase())) {
                userId = `${baseId}${counter}`;
                counter++;
            }

            return userId;
        }

        // Generate User ID from name
        function generateUserIdFromName(name) {
            const clean = name.toLowerCase().replace(/[^a-z0-9]/g, '').substring(0, 8);
            const timestamp = Date.now().toString().slice(-4);
            const random = Math.floor(Math.random() * 100).toString().padStart(2, '0');
            return `${clean}user${timestamp}${random}`;
        }

        // Enhanced Create User
        async function createUser() {
            const userNameInput = DOMUtils.get('userName');
            const userIdInput = DOMUtils.get('userIdInput');
            if (!userNameInput || !userIdInput) return;
            
            const userName = userNameInput.value.trim();
            const userId = userIdInput.value.trim();

            if (!userName) {
                showNotification('Please enter your name', 'error');
                return;
            }

            if (!userId || !isValidUserId(userId)) {
                showNotification('Please enter a valid User ID', 'error');
                return;
            }

            if (!isUserIdAvailable) {
                showNotification('Please check User ID availability', 'error');
                return;
            }

            // Create user data
            const userData = {
                id: userId,
                name: userName,
                createdAt: new Date().toISOString()
            };

            // Get return URL early (before try block) to avoid scope issues
            const urlParams = new URLSearchParams(window.location.search);
            const returnTo = sessionStorage.getItem('returnToAfterSignup') || urlParams.get('returnTo');

            try {
                // Try to create user in database if available (optional - app works without users table)
                if (typeof window.createUserInDatabase === 'function' && window.supabaseClient) {
                    try {
                        await window.createUserInDatabase(userId, userName);
                    } catch (dbError) {
                        // If users table doesn't exist, that's okay - continue with local storage
                        Logger?.debug('User creation in database skipped (table may not exist)');
                    }
                }

                // Store user data locally (always works)
                localStorage.setItem('spliteasy_current_user', JSON.stringify(userData));
                storePreviousUser(userData);

                window.currentUser = userData;
                DOMUtils.setText('currentUserName', userName);
                showMainContent();
                await loadGroups();

                // Initialize real-time sync
                if (typeof window.startRealtimeSync === 'function') {
                    setTimeout(() => {
                        window.startRealtimeSync();
                    }, 1000); // Give time for groups to load
                }

                showNotification(`Welcome, ${userName}!`);
                
                // Redirect if there's a return URL (from shared link)
                if (returnTo) {
                    sessionStorage.removeItem('returnToAfterSignup');
                    setTimeout(() => {
                        window.location.href = decodeURIComponent(returnTo);
                    }, 1500);
                }

            } catch (error) {
                Logger?.error('User creation failed:', error);
                ErrorHandler?.handle(error, 'createUser', false);
                // Even if database creation fails, continue with local storage
                localStorage.setItem('spliteasy_current_user', JSON.stringify(userData));
                storePreviousUser(userData);
                window.currentUser = userData;
                DOMUtils.setText('currentUserName', userName);
                showMainContent();
                await loadGroups();
                showNotification(`Welcome, ${userName}! (offline mode)`);
                
                // Also handle return URL in catch block
                if (returnTo) {
                    sessionStorage.removeItem('returnToAfterSignup');
                    setTimeout(() => {
                        window.location.href = decodeURIComponent(returnTo);
                    }, 1500);
                }
            }
        }

        // ========================================
        // PREVIOUS USERS MANAGEMENT
        // ========================================
        function getPreviousUsers() {
            try {
                const data = localStorage.getItem('spliteasy_previous_users');
                return data ? JSON.parse(data) : [];
            } catch (error) {
                Logger?.error('Error loading previous users:', error);
                return [];
            }
        }

        function storePreviousUser(userData) {
            try {
                let previousUsers = getPreviousUsers();

                // Remove if already exists to avoid duplicates
                previousUsers = previousUsers.filter(user => user.id !== userData.id);

                // Add to beginning of array
                previousUsers.unshift({
                    id: userData.id,
                    name: userData.name,
                    lastUsed: new Date().toISOString()
                });

                // Keep only last 10 users
                previousUsers = previousUsers.slice(0, 10);

                localStorage.setItem('spliteasy_previous_users', JSON.stringify(previousUsers));
            } catch (error) {
                Logger?.error('Error storing previous user:', error);
            }
        }

        // FIXED: Clean previous users display - no extra buttons shown
        function loadPreviousUsers() {
            const previousUsers = getPreviousUsers();
            const container = DOMUtils.get('previousUsersList');
            if (!container) return;

            // Clear container
            container.textContent = '';

            if (previousUsers.length === 0) {
                const noUsersMsg = DOMUtils.create('p', { className: 'no-users' }, 'No previous users found');
                container.appendChild(noUsersMsg);
                return;
            }

            // Create user items safely
            previousUsers.forEach(user => {
                const userItem = DOMUtils.create('div', {
                    className: 'previous-user-item',
                    'data-action': 'switchToUser',
                    'data-user-id': user.id
                });
                
                const userInfo = DOMUtils.create('div', { className: 'user-info' });
                const userName = DOMUtils.create('div', { className: 'user-name' }, escapeHtml(user.name));
                const userId = DOMUtils.create('div', { className: 'user-id' }, `ID: ${escapeHtml(user.id)}`);
                const lastUsed = DOMUtils.create('div', { className: 'last-used' }, `Last used: ${formatRelativeTime(user.lastUsed)}`);
                
                userInfo.appendChild(userName);
                userInfo.appendChild(userId);
                userInfo.appendChild(lastUsed);
                
                const deleteBtn = DOMUtils.create('button', {
                    className: 'btn-remove',
                    'data-action': 'handleDeleteAccount',
                    'data-user-id': user.id,
                    title: 'Delete Account',
                    type: 'button',
                    'aria-label': 'Delete account'
                }, '×');
                
                userItem.appendChild(userInfo);
                userItem.appendChild(deleteBtn);
                container.appendChild(userItem);
            });
        }
        
        // Helper function for switchToUser with event delegation
        function switchToUser(userId) {
            const id = userId || (typeof arguments[0] === 'string' ? arguments[0] : null);
            if (!id) {
                // Try to get from event target
                const target = arguments[0]?.currentTarget || arguments[0]?.target;
                if (target) {
                    const userItem = target.closest('.previous-user-item');
                    if (userItem) {
                        id = userItem.dataset.userId;
                    }
                }
            }
            if (!id) return;
            
            // Call the actual switch function
            switchToUserActual(id);
        }
        
        // Actual switch function
        async function switchToUserActual(userId) {
            const previousUsers = getPreviousUsers();
            const userData = previousUsers.find(user => user.id === userId);

            if (!userData) {
                showNotification('User not found', 'error');
                return;
            }

            // Create full user data
            const fullUserData = {
                id: userData.id,
                name: userData.name,
                createdAt: userData.createdAt || new Date().toISOString()
            };

            // Store as current user
            localStorage.setItem('spliteasy_current_user', JSON.stringify(fullUserData));
            storePreviousUser(fullUserData); // Update last used time

            window.currentUser = fullUserData;
            DOMUtils.setText('currentUserName', userData.name);
            showMainContent();
            loadGroups();

            // Initialize real-time sync
            if (typeof window.startRealtimeSync === 'function') {
                setTimeout(() => {
                    window.startRealtimeSync();
                }, 1000);
            }

            showNotification(`Switched to ${userData.name}`);
        }
        
        // Helper function for handleDeleteAccount with event delegation
        function handleDeleteAccount(userId, event) {
            const id = userId || (event?.target?.dataset?.userId);
            if (!id) {
                // Try to get from event target
                const target = event?.target || event?.currentTarget;
                if (target) {
                    const userItem = target.closest('.previous-user-item');
                    if (userItem) {
                        id = userItem.dataset.userId;
                    }
                }
            }
            if (!id) return;
            
            // Stop propagation if event provided
            if (event) {
                event.stopPropagation();
            }
            
            // Call the actual delete function
            handleDeleteAccountActual(id);
        }


        // ========================================
        // DELETE ACCOUNT FUNCTIONALITY (ENHANCED FOR CROSS ICON)
        // ========================================

        // FIXED: Enhanced delete account function triggered by cross icon
        async function handleDeleteAccountActual(userId) {
            // Get user data
            const previousUsers = getPreviousUsers();
            const userData = previousUsers.find(user => user.id === userId) || 
                            (window.currentUser?.id === userId ? window.currentUser : null);

            if (!userData) {
                showNotification('User not found', 'error');
                return;
            }

            const userName = userData.name;

            const confirmation = await ModalUtils.confirm(
                `WARNING: This will permanently delete the account "${userName}" and ALL associated groups and expenses!\n\n` +
                `This action cannot be undone. Are you absolutely sure?`,
                { danger: true, confirmText: 'Yes, Delete', cancelText: 'Cancel' }
            );

            if (!confirmation) {
                showNotification('Account deletion cancelled', 'info');
                return;
            }

            const finalConfirm = await ModalUtils.confirm(
                `FINAL CONFIRMATION!\n\n` +
                `Delete user: ${userName} (ID: ${userId})\n` +
                `This will delete ALL their data forever.\n\n` +
                `Click OK to proceed or Cancel to stop.`,
                { danger: true, confirmText: 'Delete Forever', cancelText: 'Cancel' }
            );

            if (!finalConfirm) {
                showNotification('Account deletion cancelled', 'info');
                return;
            }

            try {
                showNotification(`Deleting account "${userName}" and all data...`, 'info');

                // Delete from database (if function exists)
                if (typeof window.deleteUserFromDatabase === 'function') {
                    try {
                        Logger?.info('Attempting database deletion for user:', userId);
                        Logger?.info('This will delete ALL groups created by this user and ALL expenses in those groups');
                        await window.deleteUserFromDatabase(userId);
                        Logger?.info('Database deletion successful - user, groups, and expenses deleted');
                    } catch (dbError) {
                        Logger?.warn('Database deletion failed:', dbError);
                        showNotification(`Cloud deletion failed for "${userName}", but local data will be cleared`, 'warning');
                    }
                } else {
                    Logger?.debug('Database deletion function not available');
                }

                // Remove from previous users list
                let updatedPreviousUsers = getPreviousUsers().filter(user => user.id !== userId);
                localStorage.setItem('spliteasy_previous_users', JSON.stringify(updatedPreviousUsers));

                // If this was the current user, clear ALL their data
                if (window.currentUser?.id === userId) {
                    localStorage.removeItem('spliteasy_current_user');
                    localStorage.removeItem('spliteasy_groups');  // This removes all groups and their expenses
                    window.currentUser = null;
                    window.groups = [];
                    Logger?.info('All user data cleared from localStorage');

                    showNotification(`Account "${userName}" deleted successfully`, 'success');

                    // Show login modal after 2 seconds
                    setTimeout(() => {
                        const remainingUsers = getPreviousUsers();
                        showUserLoginModal(remainingUsers.length > 0);
                    }, 2000);
                } else {
                    // Just remove from list and refresh the display
                    loadPreviousUsers();
                    showNotification(`Account "${userName}" deleted successfully`, 'success');
                }

            } catch (error) {
                Logger?.error('Failed to delete user:', error);
                ErrorHandler?.handle(error, 'handleDeleteAccount', true);
            }
        }

        // Show new user form
        function showNewUserForm() {
            const previousSection = DOMUtils.get('previousUsersSection');
            const newUserForm = DOMUtils.get('newUserForm');
            if (previousSection) previousSection.style.display = 'none';
            if (newUserForm) newUserForm.style.display = 'block';

            // Clear form
            const userNameInput = DOMUtils.get('userName');
            const userIdInput = DOMUtils.get('userIdInput');
            const continueBtn = DOMUtils.get('continueBtn');
            if (userNameInput) userNameInput.value = '';
            if (userIdInput) userIdInput.value = '';
            resetUserIdStatus();
            if (continueBtn) continueBtn.disabled = true;
            isUserIdAvailable = false;

            setupUserIdInput();
            // Focus on name input for accessibility
            setTimeout(() => DOMUtils.focus('userName'), 100);
        }

        // ========================================
        // MAIN APP FUNCTIONS
        // ========================================
        function showMainContent() {
            const userLoginModal = DOMUtils.get('userLoginModal');
            const mainApp = DOMUtils.get('mainAppContent');
            if (userLoginModal) userLoginModal.style.display = 'none';
            if (mainApp) {
                mainApp.style.display = 'block';
                // Set focus to main content for screen readers (but blur immediately to avoid visual outline)
                mainApp.setAttribute('tabindex', '-1');
                mainApp.focus();
                // Blur immediately to remove focus outline while keeping accessibility announcement
                setTimeout(() => {
                    if (mainApp === document.activeElement) {
                        mainApp.blur();
                    }
                }, 0);
            }
        }

        async function loadGroups() {
            try {
                // REQUIRED: Load from Supabase first
                if (!window.supabaseClient) {
                    throw new Error('Supabase client not available');
                }

                if (!window.currentUser) {
                    Logger?.warn('No user logged in, cannot load groups');
                    window.groups = [];
                    displayGroups();
                    return;
                }

                // Show cached groups immediately for faster UI
                const cachedGroups = loadFromLocalStorage();
                if (cachedGroups.length > 0) {
                    window.groups = cachedGroups;
                    displayGroups(); // Show cached groups immediately
                }

                // Fetch groups from Supabase in background
                if (typeof window.fetchAllGroupsFromDatabase === 'function') {
                    const dbGroups = await window.fetchAllGroupsFromDatabase();
                    
                    // Also check localStorage for any groups that might not be in database yet
                    // (e.g., newly joined groups via shared link)
                    const localGroups = cachedGroups || loadFromLocalStorage();
                    
                    // Merge: combine database groups with local groups, avoiding duplicates
                    const mergedGroups = [...(dbGroups || [])];
                    const dbGroupIds = new Set(mergedGroups.map(g => g.id || g.supabaseId));
                    const dbGroupSupabaseIds = new Set(mergedGroups.map(g => g.supabaseId || g.id));
                    
                    // Track groups to remove from localStorage
                    const groupsToRemove = [];
                    
                    // Add local groups that aren't in database (e.g., newly joined groups)
                    localGroups.forEach(localGroup => {
                        const localGroupId = localGroup.id || localGroup.supabaseId;
                        const localGroupSupabaseId = localGroup.supabaseId || localGroup.id;
                        
                        // Check if group exists in database (by id or supabaseId)
                        const existsInDb = dbGroupIds.has(localGroupId) || 
                                         dbGroupSupabaseIds.has(localGroupId) ||
                                         dbGroupIds.has(localGroupSupabaseId) ||
                                         dbGroupSupabaseIds.has(localGroupSupabaseId);
                        
                        if (!existsInDb) {
                            // Check if this group was previously synced to database (has supabaseId or id is UUID)
                            const hasSupabaseId = localGroup.supabaseId || 
                                                 (localGroup.id && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(localGroup.id));
                            
                            // If group has supabaseId but doesn't exist in DB, it was deleted - remove it
                            if (hasSupabaseId) {
                                Logger?.debug('Group was synced to DB but no longer exists - removing from localStorage:', localGroup.name);
                                groupsToRemove.push(localGroup);
                            } else {
                                // Group was never synced to DB - might be newly created or joined
                                // Check if user is a member of this local group
                                const members = localGroup.members || [];
                                const userId = window.currentUser.id;
                                const userName = window.currentUser.name;
                                
                                // Check membership - handle both IDs and names
                                const isMemberById = members.includes(userId) || 
                                                   members.some(m => m && String(m).toLowerCase() === String(userId).toLowerCase());
                                
                                const isMemberByName = members.includes(userName) ||
                                                      members.some(m => m && String(m).toLowerCase() === String(userName).toLowerCase());
                                
                                const isMember = isMemberById || isMemberByName;
                                
                                // Also check if user is the creator
                                const isCreator = localGroup.createdBy === userId || localGroup.created_by === userId;
                                
                                if (isMember || isCreator) {
                                    // User is a member/creator and group was never synced - might be newly joined, add it
                                    mergedGroups.push(localGroup);
                                    Logger?.debug('Adding local group to list (not in DB but user is member, never synced):', localGroup.name);
                                } else {
                                    Logger?.debug('Skipping local group (user not a member and not in DB):', localGroup.name);
                                    groupsToRemove.push(localGroup);
                                }
                            }
                        } else {
                            Logger?.debug('Local group already in DB:', localGroup.name);
                        }
                    });
                    
                    // Remove groups from localStorage that don't exist in database or user is not a member
                    if (groupsToRemove.length > 0) {
                        const allLocalGroups = loadFromLocalStorage();
                        const filteredGroups = allLocalGroups.filter(g => {
                            return !groupsToRemove.some(toRemove => {
                                const gId = g.id || g.supabaseId;
                                const gSupabaseId = g.supabaseId || g.id;
                                const toRemoveId = toRemove.id || toRemove.supabaseId;
                                const toRemoveSupabaseId = toRemove.supabaseId || toRemove.id;
                                return gId === toRemoveId || 
                                       gSupabaseId === toRemoveId ||
                                       gId === toRemoveSupabaseId ||
                                       gSupabaseId === toRemoveSupabaseId;
                            });
                        });
                        if (filteredGroups.length < allLocalGroups.length) {
                            // Save filtered groups to localStorage
                            if (typeof window.saveGroupsToLocalStorageSafe === 'function') {
                                window.saveGroupsToLocalStorageSafe(filteredGroups);
                            } else {
                                // Fallback: direct save
                                try {
                                    localStorage.setItem('spliteasy_groups', JSON.stringify(filteredGroups));
                                    if (typeof invalidateGroupsCache === 'function') {
                                        invalidateGroupsCache();
                                    }
                                } catch (error) {
                                    Logger?.error('Failed to save filtered groups to localStorage:', error);
                                    return;
                                }
                            }
                            Logger?.info('Removed', allLocalGroups.length - filteredGroups.length, 'group(s) from localStorage (not in DB or user not a member)');
                        }
                    }
                    
                    window.groups = mergedGroups;
                    
                    // Update localStorage with merged groups
                    if (window.groups.length > 0) {
                        localStorage.setItem('spliteasy_groups', JSON.stringify(window.groups));
                    }
                    
                    Logger?.info('Loaded', window.groups.length, 'groups (', dbGroups?.length || 0, 'from DB,', localGroups.length, 'from local)');
                } else {
                    throw new Error('fetchAllGroupsFromDatabase function not available');
                }
            } catch (error) {
                Logger?.error('Failed to load groups from Supabase:', error);
                ErrorHandler?.handle(error, 'loadGroups', false);
                
                // Fallback to localStorage cache if available
                const cachedGroups = loadFromLocalStorage();
                if (cachedGroups.length > 0) {
                    Logger?.warn('Using cached groups from localStorage');
                    window.groups = cachedGroups;
                    showNotification('Using cached data. Some features may be limited.', 'warning');
                } else {
                    window.groups = [];
                    showNotification('Failed to load groups. Please check your connection.', 'error');
                }
            }
            
            displayGroups();
        }

        function loadFromLocalStorage() {
            try {
                const data = localStorage.getItem('spliteasy_groups');
                return data ? JSON.parse(data) : [];
            } catch (error) {
                Logger?.error('Error loading from localStorage:', error);
                return [];
            }
        }

        // Optimized save with batching and cache invalidation
        // Create a debounced version that works even if debounce isn't loaded yet
        let saveToLocalStorageTimeout = null;
        function saveToLocalStorage() {
            // Clear existing timeout if debounce isn't available
            if (saveToLocalStorageTimeout) {
                clearTimeout(saveToLocalStorageTimeout);
            }

            const saveFunction = () => {
                try {
                    // Calculate totals for each group
                    window.groups.forEach(group => {
                        if (group.expenses && group.expenses.length > 0) {
                            group.totalExpenses = group.expenses.reduce((sum, exp) => sum + parseFloat(exp.amount || 0), 0);
                        } else {
                            group.totalExpenses = 0;
                        }
                    });

                    // Use batchLocalStorageOperation if available, otherwise direct save
                    if (typeof batchLocalStorageOperation === 'function') {
                        batchLocalStorageOperation(() => {
                            localStorage.setItem('spliteasy_groups', JSON.stringify(window.groups));
                            if (typeof invalidateGroupsCache === 'function') {
                                invalidateGroupsCache();
                            }
                            Logger?.debug('Data saved to localStorage');
                        });
                    } else {
                        localStorage.setItem('spliteasy_groups', JSON.stringify(window.groups));
                        Logger?.debug('Data saved to localStorage');
                    }
                } catch (error) {
                    Logger?.error('Failed to save to localStorage:', error);
                }
            };

            // Use debounce if available, otherwise use setTimeout
            if (typeof debounce === 'function') {
                if (!window._debouncedSaveToLocalStorage) {
                    window._debouncedSaveToLocalStorage = debounce(saveFunction, 300);
                }
                window._debouncedSaveToLocalStorage();
            } else {
                // Fallback: simple debounce with setTimeout
                saveToLocalStorageTimeout = setTimeout(saveFunction, 300);
            }
        }

        function displayGroups() {
            const groupsList = DOMUtils.get('groupsList');
            const emptyState = DOMUtils.get('emptyState');
            const groupCount = DOMUtils.get('groupCount');

            if (!groupsList || !emptyState || !groupCount) return;

            if (window.groups.length === 0) {
                groupsList.style.display = 'none';
                emptyState.style.display = 'block';
                groupCount.textContent = '0 groups';
                return;
            }

            groupsList.style.display = 'grid';
            emptyState.style.display = 'none';
            groupCount.textContent = `${window.groups.length} group${window.groups.length !== 1 ? 's' : ''}`;

            // Clear and rebuild groups list safely
            groupsList.textContent = '';
            
            window.groups.forEach(group => {
                const groupCard = DOMUtils.create('div', { className: 'group-card' });
                
                const header = DOMUtils.create('div', { className: 'group-card-header' });
                const actions = DOMUtils.create('div', { className: 'group-card-actions' });
                
                const editBtn = DOMUtils.create('button', {
                    className: 'group-action-btn edit',
                    'data-action': 'editGroup',
                    'data-group-id': group.id,
                    title: 'Edit Group',
                    type: 'button',
                    'aria-label': 'Edit group'
                }, '✎');
                
                const deleteBtn = DOMUtils.create('button', {
                    className: 'group-action-btn delete',
                    'data-action': 'deleteGroup',
                    'data-group-id': group.id,
                    title: 'Delete Group',
                    type: 'button',
                    'aria-label': 'Delete group'
                }, '×');
                
                actions.appendChild(editBtn);
                actions.appendChild(deleteBtn);
                header.appendChild(actions);
                
                const content = DOMUtils.create('div', {
                    className: 'group-card-content',
                    'data-action': 'openGroup',
                    'data-group-id': group.id
                });
                
                const groupInfo = DOMUtils.create('div', { className: 'group-info' });
                const h3 = DOMUtils.create('h3', {}, escapeHtml(group.name));
                
                const meta = DOMUtils.create('div', { className: 'group-meta' });
                
                // Calculate participant count
                const participants = Array.isArray(group.participants) ? group.participants : [];
                const memberIds = Array.isArray(group.members) ? group.members : [];
                const participantCount = participants.filter(p => {
                    if (typeof p !== 'string') return false;
                    if (memberIds.includes(p)) return false;
                    if (p.includes('user') || p.length > 30 || /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(p)) {
                        return false;
                    }
                    return true;
                }).length;
                
                const membersSpan = DOMUtils.create('span', {}, `${participantCount} members`);
                const expensesSpan = DOMUtils.create('span', {}, `${group.expenses?.length || 0} expenses`);
                const createdSpan = DOMUtils.create('span', {}, `Created ${formatDate(group.createdAt)}`);
                
                meta.appendChild(membersSpan);
                meta.appendChild(expensesSpan);
                meta.appendChild(createdSpan);
                
                groupInfo.appendChild(h3);
                groupInfo.appendChild(meta);
                
                const amount = DOMUtils.create('div', { className: 'group-amount' }, formatCurrency(group.totalExpenses || 0));
                
                content.appendChild(groupInfo);
                content.appendChild(amount);
                
                groupCard.appendChild(header);
                groupCard.appendChild(content);
                
                groupsList.appendChild(groupCard);
            });
        }
        
        // Helper function for openGroup with event delegation
        function openGroup(groupId) {
            const id = groupId || (arguments[0]?.target?.dataset?.groupId);
            if (!id) {
                const target = arguments[0]?.target || arguments[0]?.currentTarget;
                if (target) {
                    const groupCard = target.closest('.group-card');
                    if (groupCard) {
                        const content = groupCard.querySelector('.group-card-content');
                        if (content) {
                            id = content.dataset.groupId;
                        }
                    }
                }
            }
            if (id) {
                window.location.href = `group-detail.html?id=${id}`;
            }
        }

        // ========================================
        // GROUP MANAGEMENT FUNCTIONS
        // ========================================
        function showCreateGroupModal() {
            // Check if user is logged in
            if (!window.currentUser) {
                showNotification('Please log in to create a group', 'error');
                showUserLoginModal(false);
                return;
            }
            
            const modal = DOMUtils.get('createGroupModal');
            const groupNameInput = DOMUtils.get('groupName');
            if (modal) modal.style.display = 'block';
            if (groupNameInput) {
                groupNameInput.value = '';
                // Focus on group name input for accessibility
                setTimeout(() => DOMUtils.focus('groupName'), 100);
            }
            setupMemberSelection();
        }

        function closeCreateGroupModal() {
            const modal = DOMUtils.get('createGroupModal');
            if (modal) {
                modal.style.display = 'none';
            }
            // Clear dynamic members
            const dynamicMembers = DOMUtils.get('dynamicMembers');
            if (dynamicMembers) {
                dynamicMembers.textContent = '';
            }
            dynamicMemberCounter = 0;
        }

        function setupMemberSelection() {
            const grid = DOMUtils.get('memberSelectionGrid');
            if (!grid) return;
            
            // Check if user is logged in
            if (!window.currentUser) {
                Logger?.warn('No user logged in, showing login modal');
                showUserLoginModal(false);
                return;
            }
            
            // Clear and rebuild grid safely
            grid.textContent = '';
            const userBox = DOMUtils.create('div', {
                className: 'selectable-box selected',
                'data-member': window.currentUser.name
            }, window.currentUser.name);
            grid.appendChild(userBox);
        }

        function selectAllMembers() {
            document.querySelectorAll('#memberSelectionGrid .selectable-box').forEach(box => {
                box.classList.add('selected');
            });
        }

        function clearAllMembers() {
            if (!window.currentUser) return;
            
            document.querySelectorAll('#memberSelectionGrid .selectable-box').forEach(box => {
                if (box.dataset.member !== window.currentUser.name) {
                    box.classList.remove('selected');
                }
            });
        }

        // Helper function to create member item safely
        function createMemberItem(memberName, itemId, isEditMode = false) {
            const memberItem = DOMUtils.create('div', { 
                className: 'dynamic-item',
                id: itemId
            });
            
            const content = DOMUtils.create('div', { className: 'dynamic-item-content' });
            const nameSpan = DOMUtils.create('span', { className: 'dynamic-item-name' }, memberName);
            content.appendChild(nameSpan);
            
            const actions = DOMUtils.create('div', { className: 'dynamic-item-actions' });
            const editBtn = DOMUtils.create('button', {
                className: 'icon-btn edit',
                'data-action': isEditMode ? 'editEditMember' : 'editMember',
                'data-item-id': itemId,
                title: 'Edit',
                type: 'button',
                'aria-label': 'Edit member'
            }, '✎');
            const deleteBtn = DOMUtils.create('button', {
                className: 'icon-btn delete',
                'data-action': isEditMode ? 'removeEditMember' : 'removeMember',
                'data-item-id': itemId,
                title: 'Remove',
                type: 'button',
                'aria-label': 'Remove member'
            }, '×');
            
            actions.appendChild(editBtn);
            actions.appendChild(deleteBtn);
            
            memberItem.appendChild(content);
            memberItem.appendChild(actions);
            
            return memberItem;
        }

        function addNewMember() {
            const input = DOMUtils.get('newMemberInput');
            if (!input) return;
            
            const memberName = input.value.trim();
            if (!memberName) return;

            // Check for duplicates
            const existingMembers = Array.from(document.querySelectorAll('#memberSelectionGrid .selectable-box')).map(box => box.dataset.member);
            const dynamicMembers = Array.from(document.querySelectorAll('#dynamicMembers .dynamic-item-name')).map(el => el.textContent);

            if (existingMembers.includes(memberName) || dynamicMembers.includes(memberName)) {
                showNotification('Member already exists', 'error');
                return;
            }

            const dynamicContainer = DOMUtils.get('dynamicMembers');
            if (!dynamicContainer) return;
            
            const itemId = `member${dynamicMemberCounter++}`;
            const memberItem = createMemberItem(memberName, itemId, false);
            dynamicContainer.appendChild(memberItem);
            input.value = '';
            showNotification('Member added successfully', 'success');
        }

        async function editMember(itemId) {
            const item = DOMUtils.get(itemId);
            if (!item) return;
            
            const nameEl = item.querySelector('.dynamic-item-name');
            if (!nameEl) return;
            
            const currentName = nameEl.textContent;
            const newName = await ModalUtils.prompt('Edit member name:', currentName);

            if (newName && newName.trim() && newName.trim() !== currentName) {
                nameEl.textContent = newName.trim();
                showNotification('Member updated', 'success');
            }
        }

        async function removeMember(itemId) {
            const confirmed = await ModalUtils.confirm('Remove this member?');
            if (confirmed) {
                const item = DOMUtils.get(itemId);
                if (item) {
                    item.remove();
                    showNotification('Member removed', 'success');
                }
            }
        }

        async function createGroup() {
            const groupNameInput = DOMUtils.get('groupName');
            if (!groupNameInput) return;
            const groupName = groupNameInput.value.trim();

            // Get selected members from boxes
            const selectedBoxes = document.querySelectorAll('#memberSelectionGrid .selectable-box.selected');
            const selectedMembers = Array.from(selectedBoxes).map(box => box.dataset.member);

            // Get dynamic members
            const dynamicMembers = Array.from(document.querySelectorAll('#dynamicMembers .dynamic-item-name')).map(el => el.textContent);

            const allMembers = [...selectedMembers, ...dynamicMembers];

            if (!groupName) {
                showNotification('Please enter a group name', 'error');
                return;
            }

            if (allMembers.length < 2) {
                showNotification('Group must have at least two members', 'error');
                return;
            }

            // Check if user is logged in
            if (!window.currentUser) {
                showNotification('Please log in to create a group', 'error');
                showUserLoginModal(false);
                return;
            }

            // Separate registered users from non-registered participants
            // When creating a group:
            // - members: Array of registered user IDs (creator + users who join via shared link)
            // - participants: Array of non-registered member names (for expense splitting)
            // All names entered during creation go to participants (these are used for "who paid" and "split between")
            const newGroup = {
                id: generateId(),
                name: groupName,
                members: [window.currentUser.id],  // Creator's ID is in members (for permissions)
                participants: allMembers,  // ALL entered names go to participants (for expense splitting)
                expenses: [],
                totalExpenses: 0,
                createdAt: new Date().toISOString(),
                createdBy: window.currentUser.id
            };

            try {
                // REQUIRED: Save to Supabase first
                if (!window.supabaseClient) {
                    throw new Error('Supabase client not available');
                }

                if (typeof window.syncGroupToDatabase !== 'function') {
                    throw new Error('syncGroupToDatabase function not available');
                }

                showNotification('Creating group in cloud...', 'info');
                const result = await window.syncGroupToDatabase(newGroup);
                
                if (!result) {
                    throw new Error('Group sync returned no result');
                }
                
                Logger?.info('Group created in Supabase:', result);
                
                // Add to local array and cache
                window.groups.push(newGroup);
                saveToLocalStorage();
                displayGroups();
                closeCreateGroupModal();
                
                showNotification(`Group "${groupName}" created successfully!`, 'success');
                
                // Reload groups from Supabase to ensure sync
                await loadGroups();
            } catch (error) {
                Logger?.error('Failed to create group in Supabase:', error);
                Logger?.error('Error details:', {
                    message: error.message,
                    code: error.code,
                    details: error.details,
                    hint: error.hint
                });
                ErrorHandler?.handle(error, 'createGroup', true);
            }
        }

        // ========================================
        // EDIT GROUP FUNCTIONALITY - COMPLETE IMPLEMENTATION
        // ========================================

        // FIXED: Edit Group function - main entry point
        function editGroup(groupId) {
            const id = groupId || (arguments[0]?.target?.dataset?.groupId);
            if (!id) {
                Logger?.error('No group ID provided');
                showNotification('Group not found', 'error');
                return;
            }

            // Find the group
            const group = window.groups.find(g => g.id === id);
            if (!group) {
                Logger?.error('Group not found:', id);
                Logger?.debug('Available groups:', window.groups.map(g => ({id: g.id, name: g.name})));
                showNotification('Group not found', 'error');
                return;
            }

            Logger?.debug('Found group for editing:', group.name);

            // Set editing group ID
            editingGroupId = id;

            // Show edit modal
            showEditGroupModal(group);
        }

        // Show edit group modal with group data
        function showEditGroupModal(group) {
            Logger?.debug('Setting up edit modal for:', group.name);

            // Clear any previous dynamic members
            const editDynamicContainer = DOMUtils.get('editDynamicMembers');
            if (editDynamicContainer) {
                editDynamicContainer.textContent = '';
            }
            editDynamicMemberCounter = 0;

            // Populate group name
            const editGroupNameInput = DOMUtils.get('editGroupName');
            if (editGroupNameInput) {
                editGroupNameInput.value = group.name;
                Logger?.debug('Group name populated:', group.name);
            }

            // Setup members grid
            setupEditMemberSelection(group);

            // Show modal
            const modal = DOMUtils.get('editGroupModal');
            if (modal) {
                modal.style.display = 'block';
                Logger?.debug('Edit group modal displayed');
            }
        }

        // Setup edit member selection grid
        function setupEditMemberSelection(group) {
            const grid = DOMUtils.get('editMemberSelectionGrid');
            if (!grid) {
                Logger?.error('Edit member selection grid not found');
                return;
            }

            // Clear dynamic members container
            const dynamicContainer = DOMUtils.get('editDynamicMembers');
            if (dynamicContainer) {
                dynamicContainer.textContent = '';
            }

            // Show only participants (manually added names), not registered members
            // Filter out IDs by checking if they match any registered member IDs
            const participants = Array.isArray(group.participants) ? group.participants : [];
            const memberIds = Array.isArray(group.members) ? group.members : [];
            
            // Helper to convert ID to name
            const getIdToName = (id) => {
                // Check if it's the current user
                if (window.currentUser && window.currentUser.id === id) {
                    return window.currentUser.name;
                }
                
                // Try to get from localStorage
                try {
                    const previousUsers = JSON.parse(localStorage.getItem('spliteasy_previous_users') || '[]');
                    const user = previousUsers.find(u => u.id === id);
                    if (user) return user.name;
                } catch (e) {
                    // Ignore
                }
                
                return null;
            };
            
            const participantNames = participants.map(p => {
                // First, try to convert IDs to names
                if (typeof p !== 'string') return null;
                
                // Check if this is a registered member ID (in members array)
                if (memberIds.includes(p)) {
                    return null; // This is a registered member ID, filter it out
                }
                
                // Check if p looks like an ID (pattern: letters followed by numbers, like "kaladeep0226")
                if (/^[a-zA-Z]+\d+$/.test(p)) {
                    const name = getIdToName(p);
                    if (name) {
                        // If we found a name, this is actually a registered member ID - filter it out
                        return null;
                    }
                    // If we can't convert it but it looks like an ID, filter it out anyway
                    return null;
                }
                
                // Filter out UUIDs and IDs with "user" pattern
                if (p.includes('user') || p.length > 30 || /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(p)) {
                    return null; // This looks like an ID
                }
                
                return p; // This looks like a participant name
            }).filter(p => p !== null); // Remove nulls (filtered out IDs)

            Logger?.debug('Setting up edit members for participants:', participantNames);

            if (participantNames.length === 0) {
                const emptyMsg = DOMUtils.create('p', {
                    style: 'color: var(--text-secondary); padding: 1rem;'
                }, 'No participants yet. Add participants below.');
                grid.textContent = '';
                grid.appendChild(emptyMsg);
                return;
            }

            // Clear and rebuild grid safely
            grid.textContent = '';
            participantNames.forEach(person => {
                const box = DOMUtils.create('div', {
                    className: 'selectable-box selected',
                    'data-member': person
                }, escapeHtml(person));
                grid.appendChild(box);
            });

            Logger?.debug('Edit members grid populated');
        }

        // Edit group member selection functions
        function selectAllEditMembers() {
            document.querySelectorAll('#editMemberSelectionGrid .selectable-box').forEach(box => {
                box.classList.add('selected');
            });
        }

        function clearAllEditMembers() {
            document.querySelectorAll('#editMemberSelectionGrid .selectable-box').forEach(box => {
                box.classList.remove('selected');
            });
        }

        // Add new member in edit mode
        function addNewEditMember() {
            const input = DOMUtils.get('editNewMemberInput');
            if (!input) return;
            
            const memberName = input.value.trim();
            if (!memberName) {
                showNotification('Please enter a member name', 'error');
                return;
            }

            // Check for duplicates
            const existingMembers = Array.from(document.querySelectorAll('#editMemberSelectionGrid .selectable-box')).map(box => box.dataset.member);
            const dynamicMembers = Array.from(document.querySelectorAll('#editDynamicMembers .dynamic-item-name')).map(el => el.textContent);

            if (existingMembers.includes(memberName) || dynamicMembers.includes(memberName)) {
                showNotification('Member already exists', 'error');
                return;
            }

            const dynamicContainer = DOMUtils.get('editDynamicMembers');
            if (!dynamicContainer) {
                Logger?.error('Edit dynamic members container not found');
                return;
            }

            const itemId = `editMember${editDynamicMemberCounter++}`;
            const memberItem = createMemberItem(memberName, itemId, true);
            dynamicContainer.appendChild(memberItem);
            input.value = '';
            showNotification('Member added successfully', 'success');
        }

        // Edit member in edit mode
        async function editEditMember(itemId) {
            const item = DOMUtils.get(itemId);
            if (!item) return;

            const nameEl = item.querySelector('.dynamic-item-name');
            if (!nameEl) return;

            const currentName = nameEl.textContent;
            const newName = await ModalUtils.prompt('Edit member name:', currentName);

            if (newName && newName.trim() && newName.trim() !== currentName) {
                nameEl.textContent = newName.trim();
                showNotification('Member updated', 'success');
            }
        }

        // Remove member in edit mode
        async function removeEditMember(itemId) {
            const confirmed = await ModalUtils.confirm('Remove this member?');
            if (confirmed) {
                const item = DOMUtils.get(itemId);
                if (item) {
                    item.remove();
                    showNotification('Member removed', 'success');
                }
            }
        }

        // Save edit group changes
        async function saveEditGroupChanges() {
            Logger?.info('Saving edit group changes...');

            if (!editingGroupId) {
                showNotification('No group being edited', 'error');
                return;
            }

            const group = window.groups.find(g => g.id === editingGroupId);
            if (!group) {
                showNotification('Group not found', 'error');
                return;
            }

            const editGroupNameInput = DOMUtils.get('editGroupName');
            if (!editGroupNameInput) return;
            const groupName = editGroupNameInput.value.trim();
            if (!groupName) {
                showNotification('Please enter a group name', 'error');
                return;
            }

            // Get selected members from grid
            const selectedBoxes = document.querySelectorAll('#editMemberSelectionGrid .selectable-box.selected');
            const selectedMembers = Array.from(selectedBoxes).map(box => box.dataset.member);

            // Get dynamic members
            const dynamicMembers = Array.from(document.querySelectorAll('#editDynamicMembers .dynamic-item-name')).map(el => el.textContent);

            const allMembers = [...selectedMembers, ...dynamicMembers];

            Logger?.debug('Selected participants:', selectedMembers);
            Logger?.debug('Dynamic participants:', dynamicMembers);
            Logger?.debug('All participants:', allMembers);

            // Validation
            if (allMembers.length < 2) {
                showNotification('Group must have at least two participants', 'error');
                return;
            }

            try {
                // Keep existing registered member IDs (users who joined via shared link)
                // Since edit modal only shows participants, all entered names are participants
                const existingMemberIds = Array.isArray(group.members) ? group.members : [];
                
                // All entered names are participants (remove duplicates)
                const participantNames = [...new Set(allMembers)];

                // Update group data
                const oldName = group.name;
                group.name = groupName;
                group.members = existingMemberIds;  // Keep registered user IDs unchanged
                group.participants = participantNames;  // Update participant names only

                // REQUIRED: Update in Supabase first
                if (!window.supabaseClient) {
                    throw new Error('Supabase client not available');
                }

                if (typeof window.syncGroupToDatabase !== 'function') {
                    throw new Error('syncGroupToDatabase function not available');
                }

                showNotification('Updating group in cloud...', 'info');
                await window.syncGroupToDatabase(group);
                
                // Update in localStorage cache
                saveToLocalStorage();
                displayGroups();
                closeEditGroupModal();
                
                showNotification('Group updated successfully!', 'success');
                
                // Reload groups from Supabase to ensure sync
                await loadGroups();

                Logger?.info('Group updated successfully:', {
                    oldName,
                    newName: groupName,
                    members: allMembers
                });

            } catch (error) {
                Logger?.error('Failed to save group changes:', error);
                ErrorHandler?.handle(error, 'saveEditGroupChanges', true);
            }
        }

        // Close edit group modal
        function closeEditGroupModal() {
            const modal = DOMUtils.get('editGroupModal');
            if (modal) {
                modal.style.display = 'none';
            }

            // Clear dynamic members
            const dynamicContainer = DOMUtils.get('editDynamicMembers');
            if (dynamicContainer) {
                dynamicContainer.textContent = '';
            }

            // Reset counters and editing ID
            editDynamicMemberCounter = 0;
            editingGroupId = null;
        }

        // Delete group confirmation from edit modal
        async function deleteGroupConfirm() {
            if (!editingGroupId) {
                showNotification('No group selected for deletion', 'error');
                return;
            }

            const group = window.groups.find(g => g.id === editingGroupId);
            if (!group) {
                showNotification('Group not found', 'error');
                return;
            }

            // Check if current user is the creator
            const creatorId = group.createdBy || group.created_by;
            const isCreator = window.currentUser && window.currentUser.id === creatorId;

            // If user is NOT the creator, allow them to leave the group
            if (!isCreator) {
                await handleLeaveGroup(editingGroupId, closeEditGroupModal);
                return;
            }

            // Creator deletion flow
            await handleDeleteGroup(editingGroupId, closeEditGroupModal);
        }

        // FIXED: Delete group function with database sync
        async function deleteGroup(groupId) {
            const group = window.groups.find(g => g.id === groupId);
            if (!group) return;

            // Check if current user is the creator
            const creatorId = group.createdBy || group.created_by;
            const isCreator = window.currentUser && window.currentUser.id === creatorId;

            // If user is NOT the creator, allow them to leave the group
            if (!isCreator) {
                await handleLeaveGroup(groupId);
                return;
            }

            // Creator deletion flow
            await handleDeleteGroup(groupId);
        }

        // ========================================
        // UTILITY FUNCTIONS (Using shared utilities)
        // ========================================
        // All utility functions are now in shared-utils.js
        // formatCurrency, formatDate, escapeHtml, formatRelativeTime, generateId, showNotification
        // are available globally from shared-utils.js

        // Helper function to remove group from local array (eliminates duplication)
        function removeGroupFromLocalArray(groupId) {
            window.groups = window.groups.filter(g => {
                const gId = g.id || g.supabaseId;
                const gSupabaseId = g.supabaseId || g.id;
                return gId !== groupId && gSupabaseId !== groupId;
            });
            saveToLocalStorage();
            displayGroups();
        }

        // Helper function to remove group with multiple ID checks (for complex deletion scenarios)
        function removeGroupFromLocalArrayMultiple(groupId, deletedGroupId) {
            window.groups = window.groups.filter(g => {
                const gId = g.id || g.supabaseId;
                const gSupabaseId = g.supabaseId || g.id;
                return gId !== deletedGroupId && gSupabaseId !== deletedGroupId && 
                       gId !== groupId && gSupabaseId !== groupId;
            });
            saveToLocalStorage();
            displayGroups();
        }

        // Helper function to handle leaving a group (non-creator flow)
        async function handleLeaveGroup(groupId, closeModalCallback = null) {
            const group = window.groups.find(g => g.id === groupId);
            if (!group) return;

            const confirmed = await ModalUtils.confirm(`Are you sure you want to leave the group "${group.name}"? You will no longer see this group or its expenses.`);
            if (!confirmed) return;

            try {
                // Remove user from group
                if (typeof window.removeUserFromGroup === 'function') {
                    await window.removeUserFromGroup(groupId, window.currentUser.id);
                    Logger?.info('User removed from group');
                } else {
                    throw new Error('Remove user function not available');
                }

                // Remove from local array and cache
                removeGroupFromLocalArray(groupId);
                if (closeModalCallback) closeModalCallback();
                showNotification('You have left the group', 'success');
                
                // Reload groups from Supabase to ensure sync
                await loadGroups();
            } catch (error) {
                Logger?.error('Failed to leave group:', error);
                
                // Still remove from local storage even if database update fails
                removeGroupFromLocalArray(groupId);
                if (closeModalCallback) closeModalCallback();
                showNotification('Removed from your view. Group may still show if you refresh.', 'warning');
            }
        }

        // Helper function to handle group deletion (creator flow)
        async function handleDeleteGroup(groupId, closeModalCallback = null) {
            const group = window.groups.find(g => g.id === groupId);
            if (!group) return;

            const confirmed = await ModalUtils.confirm(`Are you sure you want to delete the group "${group.name}"? This action cannot be undone.`, {
                danger: true,
                confirmText: 'Delete',
                cancelText: 'Cancel'
            });
            if (!confirmed) return;

            try {
                // REQUIRED: Delete from Supabase first
                if (!window.supabaseClient) {
                    throw new Error('Supabase client not available');
                }

                if (typeof window.deleteGroupFromDatabase !== 'function') {
                    throw new Error('deleteGroupFromDatabase function not available');
                }

                showNotification('Deleting group from cloud...', 'info');
                
                // Get the correct group ID (could be UUID from Supabase or local ID)
                const groupToDelete = window.groups.find(g => g.id === groupId || g.supabaseId === groupId);
                const deleteGroupId = groupToDelete?.supabaseId || groupToDelete?.id || groupId;
                
                Logger?.info('Deleting group with ID:', deleteGroupId, 'from group:', groupToDelete);
                
                try {
                    // Force delete immediately when creator deletes (no collaborative deletion needed)
                    await window.deleteGroupFromDatabase(deleteGroupId, true);
                    Logger?.info('Group successfully deleted from database');
                } catch (error) {
                    Logger?.error('Group deletion error:', error);
                    // If group is already deleted or not found, just remove from local storage
                    if (error.message?.includes('not found') || error.message?.includes('already deleted') || error.message?.includes('PGRST116')) {
                        Logger?.warn('Group already deleted from database, removing from local storage');
                        showNotification('Group was already deleted', 'info');
                    } else {
                        // Show the actual error to help debug
                        Logger?.error('Deletion failed with error:', error.message);
                        throw error; // Re-throw other errors
                    }
                }
                
                // Delete from local array and cache (only if DB delete succeeded)
                // Check both the original ID and the Supabase ID
                const deletedGroupId = groupToDelete?.supabaseId || groupToDelete?.id || groupId;
                removeGroupFromLocalArrayMultiple(groupId, deletedGroupId);
                if (closeModalCallback) closeModalCallback();
                showNotification('Group deleted successfully!', 'success');
                
                // Reload groups from Supabase to ensure sync and verify deletion
                await loadGroups();
            } catch (error) {
                Logger?.error('Failed to delete group:', error);
                ErrorHandler?.handle(error, 'handleDeleteGroup', true);
                // Still remove from local storage if it's a "not found" error
                if (error.message?.includes('not found') || error.message?.includes('already deleted')) {
                    removeGroupFromLocalArray(groupId);
                    if (closeModalCallback) closeModalCallback();
                    showNotification('Group removed from local storage', 'info');
                } else {
                    showNotification('Failed to delete group. Please check your connection.', 'error');
                }
            }
        }


        // ========================================
        // EVENT LISTENERS - Event Delegation
        // ========================================

        // Set up event delegation for all action buttons
        function setupEventDelegation() {
            // Action buttons with data-action attribute (click and keyboard)
            DOMUtils.delegate(document.body, '[data-action]', 'click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const action = this.dataset.action;
                const itemId = this.dataset.itemId;
                const groupId = this.dataset.groupId;
                const userId = this.dataset.userId;
                
                // Determine which ID to use
                const id = itemId || groupId || userId;
                
                if (typeof window[action] === 'function') {
                    if (id) {
                        window[action](id, e);
                    } else {
                        window[action](e);
                    }
                } else {
                    Logger?.warn('Action function not found:', action);
                }
            });
            
            // Keyboard support for action buttons (Enter and Space)
            DOMUtils.delegate(document.body, '[data-action]', 'keydown', function(e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    e.stopPropagation();
                    this.click(); // Trigger click handler
                }
            });
            
            // Keyboard support for close buttons (Escape key)
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    // Close any open modal
                    const openModal = document.querySelector('.modal[style*="block"]');
                    if (openModal) {
                        const closeAction = openModal.querySelector('[data-action*="close"], .close');
                        if (closeAction) {
                            closeAction.click();
                        }
                    }
                }
            });

            // Toggle selectable boxes
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('selectable-box')) {
                    // Don't allow deselecting current user in create mode
                    if (e.target.dataset.member === window.currentUser?.name && 
                        e.target.closest('#memberSelectionGrid')) {
                        return;
                    }
                    e.target.classList.toggle('selected');
                }
            });

            // Modal close handlers
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('modal')) {
                    e.target.style.display = 'none';
                }
            });

            // Enter key for adding members
            document.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    if (e.target.id === 'newMemberInput') {
                        addNewMember();
                    } else if (e.target.id === 'editNewMemberInput') {
                        addNewEditMember();
                    }
                }
            });
        }

        // Initialize event delegation after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupEventDelegation);
        } else {
            setupEventDelegation();
        }

        // Enhanced Service Worker Registration with Update Detection
        if ('serviceWorker' in navigator) {
            Logger?.debug('Registering service worker...');

            // Detect base path for GitHub Pages subdirectory
            const basePath = window.location.pathname.split('/').slice(0, -1).join('/') || '';
            const swPath = basePath ? `${basePath}/sw.js` : '/sw.js';
            Logger?.debug('Service worker path:', swPath);

            navigator.serviceWorker.register(swPath)
                .then(registration => {
                    Logger?.debug('Service worker registered:', registration);

                    // Check for updates every 30 seconds
                    setInterval(() => {
                        registration.update();
                    }, 30000);

                    // Listen for updates
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        Logger?.debug('New service worker found');

                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                Logger?.info('New content available, will update...');

                                // Show update notification
                                if (typeof showNotification === 'function') {
                                    showNotification('App updated! Refreshing...', 'info');
                                }

                                // Auto-refresh after 2 seconds
                                setTimeout(() => {
                                    window.location.reload();
                                }, 2000);
                            }
                        });
                    });
                })
                .catch(error => {
                    Logger?.warn('Service worker registration failed:', error);
                });

            // Listen for messages from service worker
            navigator.serviceWorker.addEventListener('message', event => {
                Logger?.debug('Message from service worker:', event.data);

                if (event.data.type === 'SW_UPDATED') {
                    if (typeof showNotification === 'function') {
                        showNotification(event.data.message, 'success');
                    } else {
                        Logger?.info(event.data.message);
                    }
                }
            });
        }

        // Helper function to manually clear cache
        window.clearAppCache = function() {
            if ('serviceWorker' in navigator && 'caches' in window) {
                // Send message to service worker
                navigator.serviceWorker.controller?.postMessage({type: 'CLEAR_CACHE'});

                // Also clear caches directly
                caches.keys().then(cacheNames => {
                    return Promise.all(
                        cacheNames.map(cacheName => caches.delete(cacheName))
                    );
                }).then(() => {
                    Logger?.info('All caches cleared manually');
                    if (typeof showNotification === 'function') {
                        showNotification('Cache cleared! App will refresh...', 'success');
                    }
                    setTimeout(() => window.location.reload(), 1000);
                });
            }
        };

        // Helper function to force update
        window.forceAppUpdate = function() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.ready.then(registration => {
                    registration.update().then(() => {
                        Logger?.info('Forced service worker update');
                        setTimeout(() => window.location.reload(), 1000);
                    });
                });
            }
        };

        Logger?.debug('Cache management helpers loaded');
        Logger?.debug('Use window.clearAppCache() to clear cache manually');  
        Logger?.debug('Use window.forceAppUpdate() to force update');

        // Debug: Log when script is fully loaded
        Logger?.debug('Index.html script fully loaded');
    </script>
</body>
</html>